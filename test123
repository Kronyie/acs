--[[
  Refactored Multi-Bot (V50 - GUI Initialization Fix)
  
  *** V50 NEW FEATURE / FIX ***
  - CRITICAL FIX: Added the missing 'setMinimizedState' function definition, which was being called in setupGUI but was undefined, causing the script to crash before the UI could finalize and appear.
  - GUI GUARANTEE: Explicitly added a check to ensure the ScreenGui is parented correctly to the LocalPlayer.
  - CRITICAL LOGGING: Added specific debug prints to the main loop and action execution functions to diagnose why the script might not be finding targets:
    1. Logs when the character's HumanoidRootPart (HRP) is found.
    2. Logs which mode (Combat/Mining) is currently running.
    3. Logs a CRITICAL message if the target search fails, including the exact names it was searching for. This helps confirm spelling/capitalization issues.

  *** V49 NEW FEATURE / FIX (Original update content) ***
  - CRITICAL LOGGING: Added specific debug prints to the main loop and action execution functions to diagnose why the script might not be finding targets.

--]]

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then return end
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse() 

local MultiGrinder = {}
MultiGrinder.__index = MultiGrinder

--//========================================================================================
--// CONFIGURATION
--//========================================================================================

local CONFIG = {
    ScriptName = "Studlands (V50)", -- V50 Update: GUI Initialization Fix
    DefaultMode = "Combat", 
    FarmSpeed = 0.05, -- Time (in seconds) between attack/mine attempts (50ms is very fast)
    
    DefaultCombatToolName = "Katana", 
    DefaultCombatTargetNames = "Warrior,Archer,Mage,Boss", 
    
    DefaultMiningToolName = "Iron Pickaxe",
    DefaultMiningTargetNames = "Iron,Rock",
}

--//========================================================================================
--// INITIALIZATION
--//========================================================================================

function MultiGrinder:new()
    local self = setmetatable({}, MultiGrinder)
    
    -- State Variables
    self.Enabled = false
    self.Mode = CONFIG.DefaultMode 
    self.CurrentTarget = nil 
    self.CurrentTargetIdentifier = nil -- V40: Persistent key for ignored list
    self.TargetAcquiredTime = nil 
    self.OriginalCameraCFrame = nil 
    self.EquippedToolName = nil 
    self.IsMinimized = false 
    self.CurrentTab = "General"
    self.LoopThread = nil
    
    -- Feature Variables
    self.IgnoredTargets = {} 
    self.AutoIgnoreEnabled = true -- V42
    
    -- Combat Variables
    self.CombatToolName = CONFIG.DefaultCombatToolName
    self.CombatTargetNames = CONFIG.DefaultCombatTargetNames
    self.PriorityLocations = {} -- V43: Stores Vector3 values of priority spots
    self.CurrentPriorityLocation = nil -- V44: Stores the active Vector3 center when farming a priority spot
    
    -- Mining Variables
    self.MiningToolName = CONFIG.DefaultMiningToolName
    self.MiningTargetNames = CONFIG.DefaultMiningTargetNames
    
    -- Remote Event References (Customize these for your game)
    self.Remotes = {
        Equip = "EquipToolEvent",    -- Replace with actual remote name
        Attack = "AttackEvent",      -- Replace with actual remote name
        Teleport = "TeleportEvent",  -- Replace with actual remote name (if needed)
        
        -- Fallback for basic exploits
        TeleportFallback = nil, 
        AttackFallback = nil,
    }
    
    -- Attempt to find remotes in ReplicatedStorage or other common places
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local FoundRemotes = {}
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
            FoundRemotes[obj.Name] = obj
        end
    end
    
    self.Remotes.AttackFallback = FoundRemotes["FireClient"] or FoundRemotes["AttackEvent"] -- Example fallback
    self.Remotes.TeleportFallback = FoundRemotes["TeleportEvent"] or FoundRemotes["SetCharacterPosition"] -- Example fallback
    
    return self
end

--//========================================================================================
--// HELPER FUNCTIONS
--//========================================================================================

function MultiGrinder:getHumanoidRootPart()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

function MultiGrinder:equipTool(toolName)
    if self.EquippedToolName == toolName then return true end

    -- Attempt to find the tool in the player's Backpack or Character
    local tool = LocalPlayer.Backpack:FindFirstChild(toolName) or LocalPlayer.Character:FindFirstChild(toolName)
    
    if tool and self.Remotes.Equip then
        -- Assuming a generic equip remote takes the tool instance or name
        self.Remotes.Equip:FireServer(tool)
        self.EquippedToolName = toolName
        return true
    elseif tool then
        -- Basic tool equipping via parenting (may not work in all games)
        tool.Parent = LocalPlayer.Character
        self.EquippedToolName = toolName
        return true
    end
    
    return false
end

function MultiGrinder:attack(target)
    if self.Remotes.Attack then
        -- Assuming a generic attack remote takes the target instance
        self.Remotes.Attack:FireServer(target)
    elseif self.Remotes.AttackFallback then
        self.Remotes.AttackFallback:FireServer(target)
    end
    -- Fallback to tool usage (may work if tool is not protected)
    local tool = LocalPlayer.Character:FindFirstChild(self.EquippedToolName)
    if tool and tool:IsA("Tool") and tool.Activated then
        tool.Activated:Fire()
    end
end

function MultiGrinder:teleport(position)
    if self.Remotes.Teleport then
        self.Remotes.Teleport:FireServer(position)
    elseif self.Remotes.TeleportFallback then
        self.Remotes.TeleportFallback:FireServer(position)
    else
        local hrp = self:getHumanoidRootPart()
        if hrp then
            hrp.CFrame = CFrame.new(position + Vector3.new(0, 3, 0)) -- Small Y offset to avoid clipping
        end
    end
end

function MultiGrinder:saveCamera(hrp)
    if not self.OriginalCameraCFrame then
        self.OriginalCameraCFrame = Camera.CFrame
        -- Point camera towards the target or at least away from the ground
        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 10, 0), hrp.Position + Vector3.new(0, 5, -10))
    end
end

local function restoreCamera(self)
    -- V47 FIX: Only restore if the CFrame was actually saved.
    if self.OriginalCameraCFrame then 
        Camera.CFrame = self.OriginalCameraCFrame 
        Camera.CameraType = Enum.CameraType.Custom
        self.OriginalCameraCFrame = nil -- V47: Explicitly set to nil after restoring.
    end
end

function MultiGrinder:getTargetNames(mode)
    local targetString = (mode == "Combat") and self.CombatTargetNames or self.MiningTargetNames
    local names = {}
    
    if targetString and targetString ~= "" then
        for name in string.gmatch(targetString, "[^,]+") do
            table.insert(names, string.trim(name))
        end
    end
    
    return names
end

-- V45 CHANGE: Major optimization to fix lag and remove V44 bug.
-- V44 CHANGE: Major overhaul to priority logic
-- V43 CHANGE: Added Priority Location logic
-- V41 CHANGE: Now returns two values: targetPart (HRP/Resource) and targetKey (Model/Resource)
function MultiGrinder:findClosestTarget(position, names)
    local closestTargetPart = nil -- The Part we teleport to (HRP or Resource Part)
    local closestTargetKey = nil -- The Model/Part instance used for persistent ignore
    local minDistance = math.huge
    local searchRadius = math.huge 

    -- V45: Priority target storage
    local priorityTargetPart = nil
    local priorityTargetKey = nil
    local priorityLocation = nil
    local minPriorityDist = math.huge -- V45: Find closest priority target to player

    local allDescendants = Workspace:GetDescendants() -- V45: Get list ONCE
    local isCombat = (self.Mode == "Combat")
    local hasPriorityLocations = (isCombat and #self.PriorityLocations > 0)

    -- V45: === SINGLE PASS OPTIMIZATION ===
    for _, obj in ipairs(allDescendants) do
        local targetPart = nil
        local targetKey = nil
        
        -- Skip players and our own character
        if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and obj.Parent == Workspace and obj ~= LocalPlayer.Character then
            local humanoid = obj:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then continue end
            
            local hrp = obj:FindFirstChild("HumanoidRootPart")
            if not hrp or not hrp.Position then continue end
            
            targetPart = hrp
            targetKey = obj -- The Model

            -- V45: Priority Check (Combat Only) - Check ALL mobs
            if hasPriorityLocations then
                if not self.IgnoredTargets[targetKey] then
                    for _, prioLoc in ipairs(self.PriorityLocations) do
                        local distToPriorityLoc = (targetPart.Position - prioLoc).Magnitude
                        
                        if distToPriorityLoc <= 10 then -- Inside radius
                            local distToPlayer = (targetPart.Position - position).Magnitude
                            if distToPlayer < minPriorityDist then
                                minPriorityDist = distToPlayer
                                priorityTargetPart = targetPart
                                priorityTargetKey = targetKey
                                priorityLocation = prioLoc -- Store the location center
                            end
                            break -- Found in a zone, no need to check other zones for this mob
                        end
                    end
                end
            end

            -- V45: Normal Target Check - Check ONLY named mobs
            for _, name in ipairs(names) do
                if string.lower(obj.Name) == string.lower(name) then 
                    
                    if targetKey and self.IgnoredTargets[targetKey] then
                        -- Skip this ignored target
                    else
                        local dist = (targetPart.Position - position).Magnitude
                        if dist < searchRadius and dist < minDistance then
                            minDistance = dist
                            closestTargetPart = targetPart
                            closestTargetKey = targetKey
                        end
                    end
                    break -- Found match, no need to check other names for this obj
                end
            end
        
        -- V45: Check for Resources (Mining)
        elseif not isCombat then
             for _, name in ipairs(names) do
                if string.lower(obj.Name) == string.lower(name) and obj:IsA("BasePart") then 
                    targetPart = obj
                    targetKey = obj -- The Part
                    
                    if targetKey and self.IgnoredTargets[targetKey] then
                        -- Skip this ignored resource
                    else
                        local dist = (targetPart.Position - position).Magnitude
                        if dist < searchRadius and dist < minDistance then
                            minDistance = dist
                            closestTargetPart = targetPart
                            closestTargetKey = targetKey
                        end
                    end
                    break -- Found match, no need to check other names for this obj
                end
            end
        end
    end -- End of single pass loop

    -- V45: Prioritize returning the priority target
    if priorityTargetPart then
        print(string.format("[Multi-Bot Debug] Priority Target Found: %s near location.", priorityTargetKey.Name))
        -- V44: Return the target Part, the Model Key, and the Priority Center Location
        return priorityTargetPart, priorityTargetKey, priorityLocation
    end
    
    -- V44: Return normal target if no priority one was found
    return closestTargetPart, closestTargetKey, nil
end

--//========================================================================================
--// ACTION EXECUTION
--//========================================================================================

function MultiGrinder:executeCombatAction(hrp)
    local toolName = self.CombatToolName
    local remotes = self.Remotes
    local target = self.CurrentTarget
    local priorityLoc = self.CurrentPriorityLocation -- V44
    
    print(string.format("[Multi-Bot Debug] MODE: Combat. HRP Found: %s", tostring(hrp.Position))) -- V49

    -- Check if the current target is nil or invalid (e.g., destroyed/killed)
    -- V44: Also check if we just cleared a priority area but the target is gone.
    local needsNewTarget = not target or not target.Parent 

    if needsNewTarget then
        local targetNames = self:getTargetNames("Combat")
        
        -- V44 CHANGE: Receive three values
        local newTarget, newTargetKey, priorityLocation = self:findClosestTarget(hrp.Position, targetNames)
        
        if not newTarget then 
            local searchList = table.concat(targetNames, ", ") -- V49
            print(string.format("[Multi-Bot CRITICAL] Combat Targets NOT found. Searching for: %s", searchList)) -- V49
            
            self.CurrentTarget = nil 
            self.CurrentTargetIdentifier = nil -- V40
            self.CurrentPriorityLocation = nil -- V44
            self.TargetAcquiredTime = nil 
            restoreCamera(self) 
            self:updateGUI() 
            return false 
        end
        
        -- New target found
        self.CurrentTarget = newTarget
        self.CurrentTargetIdentifier = newTargetKey -- V40
        self.CurrentPriorityLocation = priorityLocation -- V44
        self.TargetAcquiredTime = tick() 
        print(string.format("[Multi-Bot Debug] Acquired Target: %s (%s)", newTargetKey.Name, newTargetKey:IsA("Model") and "Model" or "Part")) -- V49
        self:updateGUI()
        
        -- Teleport to new target or priority location
        if priorityLocation then
            -- V44: Teleport to the center of the priority zone, not the specific HRP
            self:teleport(priorityLocation)
        else
            -- Normal teleport to HRP position
            self:teleport(newTarget.Position)
        end
        self:saveCamera(hrp)
        
    else
        -- Target is still valid, check tool and attack
        if not self:equipTool(toolName) then
            print(string.format("[Multi-Bot Debug] Failed to equip combat tool: %s", toolName))
            return false 
        end
        
        -- Check for auto-ignore (V42: Only if enabled)
        local humanoid = target.Parent:FindFirstChildOfClass("Humanoid")
        if self.AutoIgnoreEnabled and humanoid and self.TargetAcquiredTime and (tick() - self.TargetAcquiredTime > 10) then
            
            -- V44: If we are in a priority location, wait until the mob is dead before ignoring.
            if not self.CurrentPriorityLocation or humanoid.Health <= 0 then
                
                local targetName = target.Parent and target.Parent.Name or target.Name
                print(string.format("[Multi-Bot Debug] Target %s alive for > 10s. Auto-ignoring.", targetName))
                
                -- V40 FIX: Use the CurrentTargetIdentifier for ignoring
                if self.CurrentTargetIdentifier then
                    self.IgnoredTargets[self.CurrentTargetIdentifier] = true 
                end
                
                self.CurrentTarget = nil 
                self.CurrentTargetIdentifier = nil -- V40
                self.CurrentPriorityLocation = nil -- V44
                self.TargetAcquiredTime = nil
                restoreCamera(self)
                self:updateGUI()
                return false 
            end
        end
        
        -- Teleport to target if not in priority zone
        if not self.CurrentPriorityLocation then
            self:teleport(target.Position)
        end
        
        self:attack(target.Parent)
    end
    
    return true
end

function MultiGrinder:executeMiningAction(hrp)
    local toolName = self.MiningToolName
    local remotes = self.Remotes
    local resource = self.CurrentTarget

    print(string.format("[Multi-Bot Debug] MODE: Mining. HRP Found: %s", tostring(hrp.Position))) -- V49
    
    -- V40: Check if the resource part is gone.
    local needsNewTarget = not resource or not resource.Parent

    -- V46: *** CRITICAL FIX ***
    if needsNewTarget then
        local targetNames = self:getTargetNames("Mining")
        
        -- V41 CHANGE: Receive both values
        -- V45: findClosestTarget now returns 3 values, but mining will ignore the 3rd (priorityLocation)
        local newResource, newResourceKey = self:findClosestTarget(hrp.Position, targetNames)
        
        if not newResource then 
            local searchList = table.concat(targetNames, ", ") -- V49
            print(string.format("[Multi-Bot CRITICAL] Mining Targets NOT found. Searching for: %s", searchList)) -- V49
            
            self.CurrentTarget = nil 
            self.CurrentTargetIdentifier = nil -- V40
            self.CurrentPriorityLocation = nil -- V44
            self.TargetAcquiredTime = nil 
            restoreCamera(self)
            self:updateGUI()
            return false 
        end
        
        -- New target found
        self.CurrentTarget = newResource
        self.CurrentTargetIdentifier = newResourceKey -- V40
        self.TargetAcquiredTime = tick() 
        print(string.format("[Multi-Bot Debug] Acquired Resource: %s (%s)", newResourceKey.Name, newResourceKey:IsA("Model") and "Model" or "Part")) -- V49
        self:updateGUI()
        
        self:teleport(newResource.Position)
        self:saveCamera(hrp)
        
    else
        -- Target is still valid, check tool and attack
        if not self:equipTool(toolName) then
            print(string.format("[Multi-Bot Debug] Failed to equip mining tool: %s", toolName))
            return false 
        end
        
        self:teleport(resource.Position)
        
        self:attack(resource)
    end
    
    return true
end

--//========================================================================================
--// GUI
--//========================================================================================

-- V50 FIX: This function was missing and caused a crash on GUI setup.
function MultiGrinder:setMinimizedState(isMinimized)
    self.IsMinimized = isMinimized
    if self.MainGui and self.MainGui.MainFrame then
        -- Resize the main frame
        self.MainGui.MainFrame.Size = isMinimized and UDim2.new(0, 300, 0, 30) or UDim2.new(0, 300, 0, 400)
        
        -- Update the minimize button text
        self.MainGui.MinimizeButton.Text = isMinimized and "+" or "-"
        
        -- Hide/show tabs and content
        self.MainGui.Tabs.Visible = not isMinimized
        for _, page in pairs(self.MainGui.Pages) do
            -- Only show the current tab if not minimized
            local isCurrentTab = (page.Name == self.CurrentTab .. "Page")
            page.Visible = not isMinimized and isCurrentTab
        end
    end
end

function MultiGrinder:setupGUI()
    if self.MainGui and self.MainGui.ScreenGui then self.MainGui.ScreenGui:Destroy() end
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "MultiBotGUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 300, 0, 400)
    MainFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
    MainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = ScreenGui
    
    -- Draggable functionality
    local drag = false
    local offset = Vector2.new(0, 0)
    local TitleBar = Instance.new("Frame")
    TitleBar.Size = UDim2.new(1, 0, 0, 30)
    TitleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    TitleBar.Parent = MainFrame
    TitleBar.Active = true
    TitleBar.Draggable = true -- Use built-in dragging if available
    
    local Title = Instance.new("TextLabel")
    Title.Text = CONFIG.ScriptName
    Title.Size = UDim2.new(1, -60, 1, 0)
    Title.Position = UDim2.new(0, 0, 0, 0)
    Title.BackgroundTransparency = 1
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Font = Enum.Font.GothamBold
    Title.TextSize = 16
    Title.Parent = TitleBar
    
    local function createButton(parent, text, color, position, size)
        local button = Instance.new("TextButton")
        button.Text = text
        button.Size = size or UDim2.new(0.5, -5, 0, 25)
        button.Position = position or UDim2.new(0, 0, 0, 0)
        button.BackgroundColor3 = color or Color3.fromRGB(70, 70, 70)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.Gotham
        button.TextSize = 14
        button.Parent = parent
        return button
    end
    
    -- Minimize/Maximize Button
    local MinimizeButton = createButton(TitleBar, "-", Color3.fromRGB(90, 90, 90), UDim2.new(1, -60, 0, 0), UDim2.new(0, 30, 1, 0))
    MinimizeButton.Name = "MinimizeButton"

    -- Close Button
    local CloseButton = createButton(TitleBar, "X", Color3.fromRGB(150, 40, 40), UDim2.new(1, -30, 0, 0), UDim2.new(0, 30, 1, 0))
    CloseButton.Name = "CloseButton"

    -- Tabs Container
    local Tabs = Instance.new("Frame")
    Tabs.Size = UDim2.new(1, 0, 0, 30)
    Tabs.Position = UDim2.new(0, 0, 0, 30)
    Tabs.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    Tabs.Parent = MainFrame
    
    local TabLayout = Instance.new("UIListLayout")
    TabLayout.FillDirection = Enum.FillDirection.Horizontal
    TabLayout.Parent = Tabs
    
    local TabNames = {"General", "Combat", "Mining", "Placeholder 2"}
    local TabButtons = {}
    
    function MultiGrinder:showTab(name)
        self.CurrentTab = name
        for tabName, button in pairs(TabButtons) do
            local page = Pages[tabName]
            if tabName == name then
                button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
                if page then page.Visible = true end
            else
                button.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
                if page then page.Visible = false end
            end
        end
    end
    
    for i, name in ipairs(TabNames) do
        local button = createButton(Tabs, name, Color3.fromRGB(55, 55, 55), nil, UDim2.new(1/#TabNames, 0, 1, 0))
        button.Name = name .. "Tab"
        button.MouseButton1Click:Connect(function()
            self:showTab(name)
        end)
        TabButtons[name] = button
    end
    
    -- Content Container
    local ContentContainer = Instance.new("Frame")
    ContentContainer.Size = UDim2.new(1, 0, 1, -60)
    ContentContainer.Position = UDim2.new(0, 0, 0, 60)
    ContentContainer.BackgroundTransparency = 1
    ContentContainer.Parent = MainFrame
    
    -- Helper functions for creating content
    local function createContentPage(parent, name)
        local page = Instance.new("Frame")
        page.Name = name .. "Page"
        page.Size = UDim2.new(1, 0, 1, 0)
        page.BackgroundTransparency = 1
        page.Visible = false
        page.Parent = parent
        return page
    end
    
    local function createListLayout(parent)
        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 5)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = parent
        return layout
    end
    
    local function createTextBox(parent, defaultText, placeholder)
        local box = Instance.new("TextBox")
        box.Text = defaultText
        box.PlaceholderText = placeholder or ""
        box.Size = UDim2.new(1, -10, 0, 25)
        box.Position = UDim2.new(0.5, -15, 0, 0)
        box.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
        box.TextColor3 = Color3.fromRGB(255, 255, 255)
        box.Font = Enum.Font.Gotham
        box.TextSize = 14
        box.ClearTextOnFocus = false
        box.Parent = parent
        return box
    end
    
    local function createInputLabel(parent, text)
        local label = Instance.new("TextLabel")
        label.Text = text
        label.Size = UDim2.new(1, 0, 0, 20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.Font = Enum.Font.Gotham
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = parent
        return label
    end

    local Pages = {}
    
    -- General Page
    local GeneralPage = createContentPage(ContentContainer, "General")
    local GeneralLayout = createListLayout(GeneralPage)
    GeneralLayout.Padding = UDim.new(0, 5) 
    
    function MultiGrinder:updateGUI()
        if self.MainGui and self.MainGui.GeneralPage then
            local ToggleButton = self.MainGui.GeneralPage.ToggleButton
            local ModeButton = self.MainGui.GeneralPage.ModeButton
            local AutoIgnoreButton = self.MainGui.GeneralPage.AutoIgnoreButton -- V42
            local PriorityCountLabel = self.MainGui.CombatPage.PriorityCountLabel -- V43

            ToggleButton.Text = self.Enabled and "Auto Farm: ON" or "Auto Farm: OFF"
            ToggleButton.BackgroundColor3 = self.Enabled and Color3.fromRGB(70, 150, 70) or Color3.fromRGB(150, 70, 70)
            
            ModeButton.Text = "Mode: " .. self.Mode
            
            AutoIgnoreButton.Text = self.AutoIgnoreEnabled and "10s Auto-Ignore: ON" or "10s Auto-Ignore: OFF"
            
            PriorityCountLabel.Text = string.format("Priority Locations: %d / 10", #self.PriorityLocations)
        end
    end

    -- V48 FIX: Use generic initial settings so updateGUI sets the correct state immediately.
    local ToggleButton = createButton(GeneralPage, "Starting...", Color3.fromRGB(70, 70, 70), nil, UDim2.new(1, -10, 0, 30))
    ToggleButton.Name = "ToggleButton"
    ToggleButton.MouseButton1Click:Connect(function()
        self.Enabled = not self.Enabled
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil
        if not self.Enabled then
            restoreCamera(self)
        end
        self:updateGUI()
        print(string.format("[Multi-Bot Debug] Auto Farm Toggled: %s", self.Enabled and "ON" or "OFF"))
    end)
    
    local ModeButton = createButton(GeneralPage, "Mode: " .. self.Mode, Color3.fromRGB(70, 70, 150), nil, UDim2.new(1, -10, 0, 30))
    ModeButton.Name = "ModeButton"
    ModeButton.MouseButton1Click:Connect(function()
        self.Mode = (self.Mode == "Combat") and "Mining" or "Combat"
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil 
        restoreCamera(self)
        self:updateGUI()
        print(string.format("[Multi-Bot Debug] Mode Switched to: %s", self.Mode))
    end)

    local AutoIgnoreButton = createButton(GeneralPage, "10s Auto-Ignore: ON", Color3.fromRGB(70, 70, 70), nil, UDim2.new(1, -10, 0, 30)) -- V42
    AutoIgnoreButton.Name = "AutoIgnoreButton"
    AutoIgnoreButton.MouseButton1Click:Connect(function()
        self.AutoIgnoreEnabled = not self.AutoIgnoreEnabled
        self:updateGUI()
        print(string.format("[Multi-Bot Debug] Auto-Ignore Toggled: %s", self.AutoIgnoreEnabled and "ON" or "OFF"))
    end)

    local IgnoreButton = createButton(GeneralPage, "Ignore Current Target", Color3.fromRGB(100, 100, 100), nil, UDim2.new(1, -10, 0, 30))
    IgnoreButton.Name = "IgnoreButton"
    IgnoreButton.MouseButton1Click:Connect(function()
        if self.CurrentTargetIdentifier then
            self.IgnoredTargets[self.CurrentTargetIdentifier] = true
            print(string.format("[Multi-Bot Debug] Manually Ignored Target: %s", self.CurrentTargetIdentifier.Name or "Unknown"))
        end
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil 
        restoreCamera(self)
        self:updateGUI()
    end)
    
    local ClearIgnoreButton = createButton(GeneralPage, "Clear Ignore List", Color3.fromRGB(100, 100, 100), nil, UDim2.new(1, -10, 0, 30))
    ClearIgnoreButton.Name = "ClearIgnoreButton"
    ClearIgnoreButton.MouseButton1Click:Connect(function()
        self.IgnoredTargets = {}
        print("[Multi-Bot Debug] Ignore List Cleared.")
        self:updateGUI()
    end)
    
    Pages["General"] = GeneralPage

    -- Combat Page
    local CombatPage = createContentPage(ContentContainer, "Combat")
    local CombatLayout = createListLayout(CombatPage)
    CombatLayout.Padding = UDim.new(0, 5) 
    
    createInputLabel(CombatPage, "Combat Tool Name:")
    local CToolNameInput = createTextBox(CombatPage, self.CombatToolName, "E.g., Katana, Sword")
    CToolNameInput.Name = "CToolNameInput"
    CToolNameInput.FocusLost:Connect(function(enterPressed)
        self.CombatToolName = CToolNameInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil -- V47: Ensure reset
        self.EquippedToolName = nil
        self:updateGUI()
        print(string.format("[Multi-Bot Debug] Combat Tool updated: %s", self.CombatToolName))
    end)
    
    createInputLabel(CombatPage, "Target Mob Names (comma-separated):")
    local CTargetNamesInput = createTextBox(CombatPage, self.CombatTargetNames, "E.g., Warrior, Archer, Boss")
    CTargetNamesInput.Name = "CTargetNamesInput"
    CTargetNamesInput.FocusLost:Connect(function(enterPressed)
        self.CombatTargetNames = CTargetNamesInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil -- V47: Ensure reset
        print(string.format("[Multi-Bot Debug] Combat Targets updated: %s", self.CombatTargetNames))
    end)
    
    -- Priority Locations (V43)
    local PriorityLabel = createInputLabel(CombatPage, "--- Priority Kill Zones (10m Radius) ---")
    PriorityLabel.TextColor3 = Color3.fromRGB(255, 180, 0)
    
    local PriorityCountLabel = createInputLabel(CombatPage, string.format("Priority Locations: %d / 10", #self.PriorityLocations))
    PriorityCountLabel.Name = "PriorityCountLabel"
    
    local AddPriorityButton = createButton(CombatPage, "Add Current Location", Color3.fromRGB(50, 150, 50), nil, UDim2.new(1, -10, 0, 30))
    AddPriorityButton.Name = "AddPriorityButton"
    AddPriorityButton.MouseButton1Click:Connect(function()
        local hrp = self:getHumanoidRootPart()
        if not hrp then return end
        
        if #self.PriorityLocations < 10 then
            local newLoc = hrp.Position
            table.insert(self.PriorityLocations, newLoc)
            self:updateGUI()
            print(string.format("[Multi-Bot Debug] Added Priority Location: %s", tostring(newLoc)))
        else
            print("[Multi-Bot Debug] Cannot add more than 10 priority locations.")
        end
    end)
    
    local ClearPriorityButton = createButton(CombatPage, "Clear Priority Locations", Color3.fromRGB(150, 50, 50), nil, UDim2.new(1, -10, 0, 30))
    ClearPriorityButton.Name = "ClearPriorityButton"
    ClearPriorityButton.MouseButton1Click:Connect(function()
        self.PriorityLocations = {}
        self.CurrentPriorityLocation = nil -- V44: Reset active priority
        self:updateGUI()
        print("[Multi-Bot Debug] Cleared all priority locations.")
    end)
    
    Pages["Combat"] = CombatPage

    -- Mining Page
    local MiningPage = createContentPage(ContentContainer, "Mining")
    local MiningLayout = createListLayout(MiningPage)
    MiningLayout.Padding = UDim.new(0, 5) 
    
    createInputLabel(MiningPage, "Mining Tool Name:")
    local MToolNameInput = createTextBox(MiningPage, self.MiningToolName, "E.g., Eternium Pickaxe")
    MToolNameInput.Name = "MToolNameInput"
    MToolNameInput.FocusLost:Connect(function(enterPressed)
        self.MiningToolName = MToolNameInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil -- V47: Ensure reset
        self.EquippedToolName = nil
        self:updateGUI()
        print(string.format("[Multi-Bot Debug] Mining Tool updated: %s", self.MiningToolName))
    end)
    
    createInputLabel(MiningPage, "Resource Names (comma-separated):")
    local MTargetNamesInput = createTextBox(MiningPage, self.MiningTargetNames, "E.g., Iron, Rock, Gold")
    MTargetNamesInput.Name = "MTargetNamesInput"
    MTargetNamesInput.FocusLost:Connect(function(enterPressed)
        self.MiningTargetNames = MTargetNamesInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil -- V40
        self.CurrentPriorityLocation = nil -- V44
        self.TargetAcquiredTime = nil -- V47: Ensure reset
        print(string.format("[Multi-Bot Debug] Mining Targets updated: %s", self.MiningTargetNames))
    end)
    
    local MRangeLabel = Instance.new("TextLabel")
    MRangeLabel.Text = "Search Range: Full Map (Continuous Mining)"
    MRangeLabel.Size = UDim2.new(1, 0, 0, 20)
    MRangeLabel.BackgroundTransparency = 1
    MRangeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    MRangeLabel.Font = Enum.Font.Gotham
    MRangeLabel.TextSize = 12
    MRangeLabel.TextXAlignment = Enum.TextXAlignment.Center
    MRangeLabel.Parent = MiningPage

    Pages["Mining"] = MiningPage

    local Placeholder2Page = createContentPage(ContentContainer, "Placeholder 2")
    local Placeholder2Layout = createListLayout(Placeholder2Page)
    Placeholder2Layout.Padding = UDim.new(0, 5)

    local LabelP2 = Instance.new("TextLabel")
    LabelP2.Text = "More settings here."
    LabelP2.Size = UDim2.new(1, 0, 0, 30)
    LabelP2.BackgroundTransparency = 1
    LabelP2.TextColor3 = Color3.fromRGB(150, 150, 150)
    LabelP2.Parent = Placeholder2Page
    Pages["Placeholder 2"] = Placeholder2Page


    self.MainGui = {
        ScreenGui = ScreenGui,
        MainFrame = MainFrame,
        MinimizeButton = MinimizeButton,
        Tabs = Tabs,
        Pages = Pages,
        GeneralPage = {
            ToggleButton = ToggleButton,
            ModeButton = ModeButton,
            IgnoreButton = IgnoreButton, 
            ClearIgnoreButton = ClearIgnoreButton, 
            AutoIgnoreButton = AutoIgnoreButton, -- NEW (V42)
        },
        CombatPage = {
            ToolNameInput = CToolNameInput,
            TargetNamesInput = CTargetNamesInput,
            -- V43
            PriorityCountLabel = PriorityCountLabel,
            AddPriorityButton = AddPriorityButton,
            ClearPriorityButton = ClearPriorityButton,
        },
        MiningPage = {
            ToolNameInput = MToolNameInput,
            TargetNamesInput = MTargetNamesInput,
        }
    }

    MinimizeButton.MouseButton1Click:Connect(function()
        self:setMinimizedState(not self.IsMinimized)
    end)

    CloseButton.MouseButton1Click:Connect(function()
        if self.LoopThread then task.cancel(self.LoopThread) end
        restoreCamera(self)
        ScreenGui:Destroy()
        print("[Multi-Bot Debug] Bot script shut down.")
    end)
    
    self:setMinimizedState(self.IsMinimized)
    self:showTab(self.CurrentTab)
    
    -- V47: Need to call updateGUI once after all setup is done to set initial button states
    self:updateGUI()
    
    -- V50: CRITICAL: Explicitly set parent to guarantee GUI appears
    ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

end

--//========================================================================================
--// MAIN LOOP
--//========================================================================================

function MultiGrinder:start()
    self:setupGUI()
    print("[Multi-Bot Debug] GUI Initialized. Starting main loop.")
    
    self.LoopThread = task.spawn(function()
        while task.wait(CONFIG.FarmSpeed) do
            if self.Enabled then
                local hrp = self:getHumanoidRootPart()
                
                if not hrp then 
                    -- print("[Multi-Bot Debug] Waiting for character HRP...")
                    continue 
                end
                
                if self.Mode == "Combat" then
                    self:executeCombatAction(hrp)
                elseif self.Mode == "Mining" then
                    self:executeMiningAction(hrp)
                end
            end
        end
    end)
end

--//========================================================================================
--// SCRIPT EXECUTION
--//========================================================================================

pcall(function()
    local bot = MultiGrinder:new()
    bot:start()
    print("[Multi-Bot Debug] Script finished initial execution block successfully.")
end)
