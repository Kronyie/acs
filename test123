--[[
  Refactored Multi-Bot (V44 - Equal Priority Targeting - Reduced Area)
  
  *** V44 CHANGES / FIXES (As in original file) ***
  - Logic Update: Removed "first-to-last" priority ordering for all target name lists.
    - All mobs matching any name in the 'Target Names' list are now treated with equal priority.
    - This also applies to 'Priority Mob Names'.
  - Area Update: Reduced Priority Area radius from 50 to 25.
  - Fix: Improved Ignored Mob Logic.
    - Targeting logic now strictly respects the 'IgnoredMobs' list. Mobs added to this list (manually or due to combat failure) will not be targeted again until the list is explicitly cleared or the mob is killed by other means.
    
  *** V45 NEW CHANGES (UI Implementation) ***
  - ADDED: Full UI creation logic within MultiGrinder:setupGUI().
  - ADDED: Basic UI elements (Main Frame, Close Button, Enable/Disable Button).
--]]

--//========================================================================================
--// CONFIGURATION AND CONSTANTS
--//========================================================================================

local CONFIG = {
    FarmSpeed = 0.1,
    -- V44 Update: Priority Area Radius reduced from 50 to 25
    PRIORITY_AREA_RADIUS = 25, 
    -- Other configurations (e.g., jump, skill usage, target names) would go here
    TargetNames = {}, -- Example list
    PriorityMobNames = {}, -- Example list
}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local MultiGrinder = {}
MultiGrinder.__index = MultiGrinder

--//========================================================================================
--// INITIALIZATION
--//========================================================================================

function MultiGrinder:new()
    local self = setmetatable({
        Enabled = false,
        Mode = "Combat", -- or "Mining"
        IsMinimized = false,
        CurrentTab = "Combat",
        LoopThread = nil,
        TargetMob = nil,
        
        -- V44 Update: Dictionary for O(1) ignored mob checks (mob:Instance -> true)
        IgnoredMobs = {}, 
        
        PriorityAreas = {}, -- Stores {{Position = Vector3, Radius = 25}}
        AutoIgnoreActive = true,

        -- NEW: References to created UI objects
        ScreenGui = nil, 
        MainFrame = nil,
        EnableButton = nil,
        CloseButton = nil,
    }, MultiGrinder)
    
    return self
end

--//========================================================================================
--// HELPER FUNCTIONS
--//========================================================================================

function MultiGrinder:getHumanoidRootPart()
    local char = LocalPlayer.Character
    if char then
        return char:FindFirstChild("HumanoidRootPart")
    end
    return nil
end

function MultiGrinder:isMobIgnored(mob)
    return self.IgnoredMobs[mob] ~= nil
end

function MultiGrinder:ignoreMob(mob, permanent)
    -- ... (Same logic as before)
    if permanent or not self.AutoIgnoreActive then
        self.IgnoredMobs[mob] = true
        -- In a real script, this print would be a log message
    else
        -- Logic for 10s auto-ignore (temporary) would be handled elsewhere
        -- In a real script, this print would be a log message
    end
end

function MultiGrinder:getTargetMob(hrp)
    -- ... (Same targeting logic as before)
    local maxDistance = 200 
    local closestMob = nil
    local minDistance = math.huge
    local targetMobNames = self.TargetNames 
    
    local function isNameMatch(mobName, nameList)
        for _, name in ipairs(nameList) do
            if mobName:lower():match(name:lower()) then
                return true
            end
        end
        return false
    end

    -- 1. Check Priority Areas (Highest Priority)
    if self.PriorityAreas and #self.PriorityAreas > 0 and #self.PriorityMobNames > 0 then
        local priorityMobs = {}
        
        for _, area in ipairs(self.PriorityAreas) do
            local radius = CONFIG.PRIORITY_AREA_RADIUS
            
            for _, mob in ipairs(Workspace:GetChildren()) do
                if mob:FindFirstChild("Humanoid") and mob.Name ~= LocalPlayer.Name and not self:isMobIgnored(mob) then
                    local hrp = mob:FindFirstChild("HumanoidRootPart")
                    if hrp and (hrp.Position - area.Position).Magnitude <= radius and isNameMatch(mob.Name, self.PriorityMobNames) then
                        table.insert(priorityMobs, mob)
                    end
                end
            end
        end

        if #priorityMobs > 0 then
            local closestPriorityMob = nil
            local minPrioDistance = math.huge
            for _, mob in ipairs(priorityMobs) do
                local dist = (mob.HumanoidRootPart.Position - hrp.Position).Magnitude
                if dist < minPrioDistance then
                    minPrioDistance = dist
                    closestPriorityMob = mob
                end
            end
            if closestPriorityMob then
                return closestPriorityMob
            end
        end
    end

    -- 2. Check Regular Targets (Standard Farming)
    for _, mob in ipairs(Workspace:GetChildren()) do
        if mob:FindFirstChild("Humanoid") and mob.Name ~= LocalPlayer.Name and not self:isMobIgnored(mob) then
            -- V44 Update: Check if mob's name is in the list (Equal Priority for all names)
            if isNameMatch(mob.Name, targetMobNames) then 
                local mobHRP = mob:FindFirstChild("HumanoidRootPart")
                if mobHRP then
                    local dist = (mobHRP.Position - hrp.Position).Magnitude
                    if dist <= maxDistance and dist < minDistance then
                        minDistance = dist
                        closestMob = mob
                    end
                end
            end
        end
    end
    
    return closestMob
end

function MultiGrinder:executeCombatAction(hrp)
    self.TargetMob = self:getTargetMob(hrp)

    if self.TargetMob and not self:isMobIgnored(self.TargetMob) then
        -- Combat logic (move, attack, use skills)
        -- In a real script, this print would be a log message
    else
        -- In a real script, this print would be a log message
    end
end

function MultiGrinder:executeMiningAction(hrp)
    -- Your mining logic here
    -- In a real script, this print would be a log message
end

-- Placeholder UI/Flow control functions
local function restoreCamera(self) 
    -- Actual camera restore logic would be here
end
local function minimizeScript(self) 
    -- Actual minimize logic would be here
end

function MultiGrinder:updateEnableButton()
    if self.EnableButton then
        self.EnableButton.Text = self.Enabled and "Disable Bot" or "Enable Bot"
        self.EnableButton.BackgroundColor3 = self.Enabled and Color3.new(0, 1, 0) or Color3.new(1, 0, 0) -- Green or Red
    end
end

--//========================================================================================
--// CORE UI IMPLEMENTATION (THE MISSING PART)
--//========================================================================================

function MultiGrinder:setupGUI()
    if not LocalPlayer:IsDescendantOf(Players) then return end -- Safety check

    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    -- 1. Create ScreenGui
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "MultiBot_V45_UI"
    ScreenGui.Parent = PlayerGui
    self.ScreenGui = ScreenGui

    -- 2. Create Main Frame
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 200, 0, 150)
    MainFrame.Position = UDim2.new(0.5, -100, 0.5, -75) -- Center of screen
    MainFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    MainFrame.BorderSizePixel = 0
    MainFrame.ZIndex = 10
    MainFrame.Parent = ScreenGui
    self.MainFrame = MainFrame

    -- 3. Create Title Label
    local TitleLabel = Instance.new("TextLabel")
    TitleLabel.Name = "TitleLabel"
    TitleLabel.Size = UDim2.new(1, 0, 0, 30)
    TitleLabel.Text = "Multi-Bot V45"
    TitleLabel.Font = Enum.Font.SourceSansBold
    TitleLabel.TextColor3 = Color3.new(1, 1, 1)
    TitleLabel.BackgroundColor3 = Color3.new(0, 0, 0)
    TitleLabel.BorderSizePixel = 0
    TitleLabel.Parent = MainFrame

    -- 4. Create Enable/Disable Button
    local EnableButton = Instance.new("TextButton")
    EnableButton.Name = "EnableButton"
    EnableButton.Size = UDim2.new(0.9, 0, 0, 40)
    EnableButton.Position = UDim2.new(0.05, 0, 0.3, 0)
    EnableButton.Font = Enum.Font.SourceSans
    EnableButton.TextColor3 = Color3.new(1, 1, 1)
    EnableButton.BackgroundColor3 = Color3.new(1, 0, 0) -- Start as Red (Disabled)
    EnableButton.Text = "Enable Bot"
    EnableButton.Parent = MainFrame
    self.EnableButton = EnableButton
    self:updateEnableButton() -- Set initial state

    -- 5. Create Close Button
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0.9, 0, 0, 40)
    CloseButton.Position = UDim2.new(0.05, 0, 0.65, 0)
    CloseButton.Font = Enum.Font.SourceSans
    CloseButton.TextColor3 = Color3.new(1, 1, 1)
    CloseButton.BackgroundColor3 = Color3.new(0.6, 0.1, 0.1) -- Dark Red
    CloseButton.Text = "Close Script"
    CloseButton.Parent = MainFrame
    self.CloseButton = CloseButton

    print("[Multi-Bot Debug] GUI Elements Created and Inserted.")

    --//========================================================================================
    --// UI CONNECTIONS
    --//========================================================================================

    -- Connect Enable/Disable Button
    self.EnableButton.MouseButton1Click:Connect(function()
        self.Enabled = not self.Enabled
        self:updateEnableButton()
        print(string.format("[Multi-Bot Debug] Bot toggled %s.", self.Enabled and "ON" or "OFF"))
    end)
    
    -- Connect Close Button (Uses the reference stored in self.CloseButton)
    self.CloseButton.MouseButton1Click:Connect(function()
        if self.LoopThread then task.cancel(self.LoopThread) end
        restoreCamera(self)
        self.ScreenGui:Destroy() -- Destroy the entire UI
        print("[Multi-Bot Debug] Bot script shut down and UI destroyed.")
    end)
    
    -- You can add logic here to make the MainFrame draggable
    local dragging
    local dragStart
    local startPos

    TitleLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    TitleLabel.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if dragging then
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

end

--//========================================================================================
--// MAIN LOOP
--//========================================================================================

function MultiGrinder:start()
    self:setupGUI() -- Call the updated GUI setup
    print("[Multi-Bot Debug] GUI Initialized. Starting main loop.")
    
    self.LoopThread = task.spawn(function()
        while task.wait(CONFIG.FarmSpeed) do
            if self.Enabled then
                local hrp = self:getHumanoidRootPart()
                
                if not hrp then 
                    continue 
                end
                
                if self.Mode == "Combat" then
                    self:executeCombatAction(hrp) -- This now uses the V44 targeting logic
                elseif self.Mode == "Mining" then
                    self:executeMiningAction(hrp)
                end
            end
        end
    end)
end

--//========================================================================================
--// SCRIPT EXECUTION
--//========================================================================================

pcall(function()
    if LocalPlayer then
        local bot = MultiGrinder:new()
        bot:start()
    else
        warn("LocalPlayer not found. The script must be executed locally.")
    end
end)
