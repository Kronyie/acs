--[[\
  Refactored Multi-Bot (V43 - Priority Targeting - Multi-Area)
  
  *** USER MODIFICATIONS (V44) ***
  1. Target Names Priority Removed: The main "Target Names" list no longer uses "first-to-last" priority. It now targets the overall nearest mob whose name is in the list.
  2. Priority Area Radius Reduced: Changed the default and GUI radius from 50 to 25.
  3. Ignore Mob Fix: Modified getMobs to filter out ignored mobs immediately, preventing the bot from re-targeting them.
  
  *** V43 NEW FEATURES ***
  - Feature: Text Box Priority Targeting.
    - The bot now prioritizes targets in the "Target Names" list from first to last.
    - It will attempt to kill all mobs matching the first name before moving to the second, and so on.
    - This applies to Combat, Mining, AND the new Priority Area mobs.
  
  - Feature: Priority Area Targeting (Combat Tab) - NOW SUPPORTS MULTIPLE AREAS!
    - Added "Area Priority: ON/OFF" toggle to the Combat tab.
    - Added "Priority Mob Names (First > Last)" text box.
    - Added "Set Priority Area (Radius 50)" button: Sets a 50-stud radius priority zone at your character's current position. You can set up to 5 areas.
    - Added "Clear Priority Areas" button: Clears ALL priority zones.
  - Logic:
    - When "Area Priority" is ON and Areas are set, the bot will *constantly* scan ALL defined areas for mobs from your "Priority Mob Names" list.
    - If it finds a priority mob, it will *immediately stop its current action* (even mid-fight) to kill the priority mob.
    - It respects the "first-to-last" order for the priority mob names.

  *** V42 NEW FEATURE ***
  - Added "10s Auto-Ignore: ON/OFF" toggle button to the General tab.
  - This allows you to disable the feature that automatically ignores mobs if they are not killed within 10 seconds.
  - The feature is ON by default.
--]]

--//========================================================================================
--// SERVICES & OBJECTS
--//========================================================================================

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService") -- Required for generating UUIDs

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

--//========================================================================================
--// CONFIGURATION
--//========================================================================================

local CONFIG = {
    -- General Settings
    FarmSpeed = 0.05, -- Wait time between main loop iterations (50ms)
    IgnoreTimeout = 10, -- Time (seconds) to ignore a mob after failed kill/timeout
    
    -- Targeting Settings
    TargetSearchRadius = 150, -- Max radius for standard combat search
    
    -- *** MODIFIED: Reduced Priority Area Radius from 50 to 25 ***
    PriorityAreaRadius = 25, -- The radius for priority area checking
    
    -- Default Data (User editable via GUI)
    TargetNames = {"Mob_A", "Mob_B"}, -- Names of mobs to target (comma separated)
    PriorityMobNames = {"VIP_Mob"}, -- Names of priority mobs (comma separated)
    MiningNames = {"Resource_C"}, -- Names of resources to mine (comma separated)
    
    -- Feature Toggles
    AutoIgnoreEnabled = true,
    AreaPriorityEnabled = false,
    
    -- Keybinds
    ToggleKey = Enum.KeyCode.F2,
    
    -- UI Aesthetics
    MainColor = Color3.fromRGB(44, 62, 80),  -- Dark Blue/Grey
    AccentColor = Color3.fromRGB(52, 152, 219), -- Light Blue
    TextColor = Color3.fromRGB(236, 240, 241), -- White/Light Grey
    Font = Enum.Font.SourceSans
}

--//========================================================================================
--// HELPER FUNCTIONS & CLASSES
--//========================================================================================

-- Helper to safely convert comma-separated string to a list of lower-cased strings
local function parseNameList(nameString)
    local list = {}
    if not nameString or nameString == "" then return list end
    
    for name in string.gmatch(nameString, "[^,]+") do
        local trimmedName = string.match(name, "%S.*%S") or name:match("^%s*(.-)%s*$")
        if trimmedName and trimmedName ~= "" then
            table.insert(list, trimmedName:lower())
        end
    end
    return list
end

-- Mob Wrapper Class (Minimalist implementation for demonstration)
local Mob = {}
Mob.__index = Mob

function Mob:new(mobPart)
    local self = setmetatable({}, Mob)
    self.Part = mobPart
    self.MobId = mobPart:GetAttribute("MobId") or HttpService:GenerateGUID(false)
    self.Name = mobPart.Parent.Name
    self.IsIgnored = false -- Flag to track if the mob is currently ignored
    return self
end

function Mob:getPart()
    return self.Part
end

-- MultiGrinder Main Class
local MultiGrinder = {}
MultiGrinder.__index = MultiGrinder

function MultiGrinder:new()
    local self = setmetatable({}, MultiGrinder)
    
    -- State
    self.Enabled = false
    self.Mode = "Combat" -- "Combat" or "Mining"
    self.CurrentTab = "Combat"
    self.IsMinimized = false
    
    -- Data
    self.Config = CONFIG
    self.PriorityAreas = {} -- { {Center: Vector3, Id: UUID}, ... }
    self.Mobs = {} -- Dictionary of tracked Mob objects
    self.IgnoredMobs = {} -- Dictionary of mobs currently marked as ignored (MobId -> Mob)
    self.CurrentTarget = nil
    
    -- Threading
    self.LoopThread = nil
    
    -- Utility
    self:setupListeners()
    
    return self
end

function MultiGrinder:setupListeners()
    -- Keybind Toggle
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == self.Config.ToggleKey then
            self.Enabled = not self.Enabled
            self:updateGUIState()
        end
    end)
    
    -- Mob tracking/cleanup (Simplistic approach: check everything in workspace)
    RunService.Heartbeat:Connect(function()
        local newMobs = {}
        for _, part in ipairs(Workspace:GetChildren()) do
            if part.Name:lower():find("mob") or part.Name:lower():find("resource") then
                -- Assume valid mob/resource has a part with Humanoid or similar structure
                local mobPart = part:FindFirstChild("HumanoidRootPart") or part:FindFirstChild("PrimaryPart")
                if mobPart and mobPart.CFrame.Position.Y > -100 then -- Simple filter for valid ground mobs
                    local mobId = mobPart:GetAttribute("MobId") or HttpService:GenerateGUID(false)
                    
                    if not self.Mobs[mobId] then
                        self.Mobs[mobId] = Mob:new(mobPart)
                        -- Ensure the newly created mob checks against the IgnoredMobs dictionary
                        if self.IgnoredMobs[mobId] then
                            self.Mobs[mobId].IsIgnored = true
                        end
                    end
                    newMobs[mobId] = self.Mobs[mobId]
                end
            end
        end
        self.Mobs = newMobs
    end)
end

function MultiGrinder:getHumanoidRootPart()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

--//========================================================================================
--// CORE LOGIC - TARGETING
--//========================================================================================

-- *** MODIFIED: Added IsIgnored check for robust ignoring fix ***
function MultiGrinder:getMobs(radius)
    local hrp = self:getHumanoidRootPart()
    if not hrp then return {} end
    
    local mobs = {}
    for _, mob in pairs(self.Mobs) do
        -- FIX: Only include mobs that are within radius AND are NOT ignored
        if not mob.IsIgnored and (hrp.Position - mob:getPart().Position).Magnitude <= radius then
            table.insert(mobs, mob)
        end
    end
    return mobs
end

-- *** MODIFIED: Logic refactored to remove "first-to-last" name priority for standard targets (TargetNames) ***
function MultiGrinder:findTarget(hrp, targetsTable, targetNames, searchRadius)
    if not targetsTable then return nil end

    local nearestTarget = nil
    local nearestDistance = searchRadius or math.huge

    -- Create a quick lookup set for allowed target names
    local targetNameSet = {}
    if targetNames then
        for _, name in ipairs(targetNames) do
            targetNameSet[name:lower()] = true
        end
    end

    -- If no specific names are provided, assume any mob in the table is valid (fallback)
    local checkName = #targetNames > 0

    if checkName and self.Config.AreaPriorityEnabled and targetNames == parseNameList(self.Config.PriorityMobNames) then
        -- This block retains the priority-by-order logic ONLY for Priority Mob Names
        for _, targetName in ipairs(targetNames) do
            local currentBest = nil
            local currentBestDistance = nearestDistance

            for _, mob in ipairs(targetsTable) do
                if mob.Name:lower() == targetName:lower() and not mob.IsIgnored then
                    local distance = (hrp.Position - mob:getPart().Position).Magnitude
                    if distance <= currentBestDistance then
                        currentBestDistance = distance
                        currentBest = mob
                    end
                end
            end

            if currentBest then
                return currentBest -- FOUND the nearest mob of the highest priority, so return immediately.
            end
        end
        return nil -- No targets of any priority found
    else
        -- NEW LOGIC FOR STANDARD TARGET NAMES: Find the nearest mob whose name is ANYWHERE in the list
        for _, mob in ipairs(targetsTable) do
            -- Ensure mob is in the allowed set of names AND is not ignored
            if (not checkName or targetNameSet[mob.Name:lower()]) and not mob.IsIgnored then
                local distance = (hrp.Position - mob:getPart().Position).Magnitude
                if distance <= nearestDistance then
                    nearestDistance = distance
                    nearestTarget = mob
                end
            end
        end

        if nearestTarget and nearestDistance <= searchRadius then
            return nearestTarget
        else
            return nil
        end
    end
end


function MultiGrinder:getNearestTarget()
    local hrp = self:getHumanoidRootPart()
    if not hrp then return nil end
    
    local mobs = self:getMobs(self.Config.TargetSearchRadius) -- Get all nearby, non-ignored mobs
    
    -- 1. PRIORITY AREA CHECK
    if self.Config.AreaPriorityEnabled and #self.PriorityAreas > 0 then
        local priorityNames = parseNameList(self.Config.PriorityMobNames)
        
        if #priorityNames > 0 then
            local areaTargets = {}
            for _, mob in ipairs(mobs) do
                for _, area in ipairs(self.PriorityAreas) do
                    -- *** NOTE: Radius check uses the modified PriorityAreaRadius (25) ***
                    if (area.Center - mob:getPart().Position).Magnitude <= self.Config.PriorityAreaRadius then
                        table.insert(areaTargets, mob)
                        break -- Found in one area, move to next mob
                    end
                end
            end
            
            if #areaTargets > 0 then
                -- Use findTarget with the PriorityMobNames list (which still uses name-order priority)
                local priorityTarget = self:findTarget(hrp, areaTargets, priorityNames, self.Config.PriorityAreaRadius)
                if priorityTarget then
                    return priorityTarget
                end
            end
        end
    end
    
    -- 2. STANDARD COMBAT/MINING TARGETING (Uses the refactored, non-priority logic)
    if self.Mode == "Combat" then
        local targetNames = parseNameList(self.Config.TargetNames)
        local target = self:findTarget(hrp, mobs, targetNames, self.Config.TargetSearchRadius)
        if target then
            return target
        end
    elseif self.Mode == "Mining" then
        local targetNames = parseNameList(self.Config.MiningNames)
        local target = self:findTarget(hrp, mobs, targetNames, self.Config.TargetSearchRadius)
        if target then
            return target
        end
    end
    
    return nil
end

function MultiGrinder:ignoreMob(mob, reason)
    print(string.format("[Multi-Bot Debug] Ignoring mob %s (ID: %s) for %s seconds. Reason: %s", mob.Name, mob.MobId, self.Config.IgnoreTimeout, reason))
    
    mob.IsIgnored = true
    self.IgnoredMobs[mob.MobId] = mob -- Add to dictionary
    
    -- Update GUI (if necessary, placeholder)
    self:updateStatus(string.format("Ignoring: %s", mob.Name))
    
    -- Schedule removal from IgnoredMobs after timeout
    task.spawn(function()
        task.wait(self.Config.IgnoreTimeout)
        if self.IgnoredMobs[mob.MobId] == mob then
            self.IgnoredMobs[mob.MobId] = nil
            mob.IsIgnored = false -- Reset flag on the mob object for safety, in case it's reused
            print(string.format("[Multi-Bot Debug] Mob %s (ID: %s) unignored.", mob.Name, mob.MobId))
            self:updateStatus("Ready")
        end
    end)
end

function MultiGrinder:executeCombatAction(hrp)
    local target = self:getNearestTarget()
    
    if target then
        self.CurrentTarget = target
        
        -- Start timer to check if mob is killed (for auto-ignore)
        local killAttemptTime = tick()
        local isTargetKilled = false
        
        -- Move to target and attack (Simulated)
        local mobPart = target:getPart()
        if mobPart then
            print(string.format("[Multi-Bot Debug] Attacking %s at distance %.1f", target.Name, (hrp.Position - mobPart.Position).Magnitude))
            self:updateStatus("Attacking: " .. target.Name)
            
            -- Simulate Combat Loop
            while target.IsIgnored == false and (tick() - killAttemptTime) < self.Config.IgnoreTimeout do
                -- Check if target is still valid/alive (e.g., check parent exists, health, etc.)
                if not mobPart.Parent or not mobPart.Parent:FindFirstChildOfClass("Humanoid") or mobPart.Parent:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    isTargetKilled = true
                    break
                end
                
                -- Simulated movement/attack code here
                task.wait(0.1)
            end
        end
        
        if isTargetKilled then
            print(string.format("[Multi-Bot Debug] Target %s killed.", target.Name))
            self.CurrentTarget = nil
            self:updateStatus("Killed: " .. target.Name)
        elseif self.Config.AutoIgnoreEnabled and target.IsIgnored == false and (tick() - killAttemptTime) >= self.Config.IgnoreTimeout then
            self:ignoreMob(target, "Kill timed out")
            self.CurrentTarget = nil
        end
    else
        -- No target found, move to farming position or idle
        self:updateStatus("Idling / No Targets")
        -- Simulated idle movement/repositioning
    end
end

function MultiGrinder:executeMiningAction(hrp)
    local target = self:getNearestTarget()
    
    if target then
        self.CurrentTarget = target
        
        -- Start timer to check if resource is depleted (for auto-ignore)
        local attemptTime = tick()
        local isDepleted = false
        
        -- Move to resource and mine (Simulated)
        local mobPart = target:getPart()
        if mobPart then
            print(string.format("[Multi-Bot Debug] Mining %s at distance %.1f", target.Name, (hrp.Position - mobPart.Position).Magnitude))
            self:updateStatus("Mining: " .. target.Name)
            
            -- Simulate Mining Loop
            while target.IsIgnored == false and (tick() - attemptTime) < self.Config.IgnoreTimeout do
                -- Check if resource is still valid (e.g., check parent exists, or a "health" attribute)
                if not mobPart.Parent or not mobPart.Parent:GetAttribute("ResourceHealth") or mobPart.Parent:GetAttribute("ResourceHealth") <= 0 then
                    isDepleted = true
                    break
                end
                
                -- Simulated mining/interaction code here
                task.wait(0.1)
            end
        end
        
        if isDepleted then
            print(string.format("[Multi-Bot Debug] Resource %s depleted.", target.Name))
            self.CurrentTarget = nil
            self:updateStatus("Depleted: " .. target.Name)
        elseif self.Config.AutoIgnoreEnabled and target.IsIgnored == false and (tick() - attemptTime) >= self.Config.IgnoreTimeout then
            self:ignoreMob(target, "Mining timed out")
            self.CurrentTarget = nil
        end
    else
        self:updateStatus("Idling / No Resources")
    end
end

--//========================================================================================
--// GUI (MINIMAL IMPLEMENTATION)
--//========================================================================================

local function createGUIElement(class, props)
    local element = Instance.new(class)
    for k, v in pairs(props) do
        element[k] = v
    end
    return element
end

function MultiGrinder:updateGUIState()
    local ScreenGui = self.ScreenGui
    if not ScreenGui then return end
    local MainFrame = ScreenGui:FindFirstChild("MainFrame")
    
    if MainFrame then
        local StatusLabel = MainFrame:FindFirstChild("StatusLabel")
        local ToggleButton = MainFrame:FindFirstChild("ToggleButton")
        
        if StatusLabel then
            StatusLabel.Text = "Status: " .. (self.Enabled and "ACTIVE" or "DISABLED")
            StatusLabel.TextColor3 = self.Enabled and Color3.fromRGB(46, 204, 113) or self.Config.TextColor
        end
        
        if ToggleButton then
            ToggleButton.Text = self.Enabled and "DISABLE (F2)" or "ENABLE (F2)"
            ToggleButton.BackgroundColor3 = self.Enabled and Color3.fromRGB(231, 76, 60) or self.Config.AccentColor
        end
    end
end

function MultiGrinder:updateStatus(message)
    local ScreenGui = self.ScreenGui
    if not ScreenGui then return end
    local MainFrame = ScreenGui:FindFirstChild("MainFrame")
    
    if MainFrame then
        local InfoLabel = MainFrame:FindFirstChild("InfoLabel")
        if InfoLabel then
            InfoLabel.Text = "Mode: " .. self.Mode .. " | " .. message
        end
    end
end

function MultiGrinder:createButton(text, size, position, callback)
    local button = createGUIElement("TextButton", {
        Size = UDim2.new(0, size.X, 0, size.Y),
        Position = UDim2.new(0, position.X, 0, position.Y),
        Text = text,
        Font = self.Config.Font,
        TextSize = 14,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = self.Config.AccentColor,
        BorderSizePixel = 0,
        AutoButtonColor = false,
    })
    
    local padding = createGUIElement("UIPadding", {
        PaddingTop = UDim.new(0, 5),
        PaddingBottom = UDim.new(0, 5),
        PaddingLeft = UDim.new(0, 5),
        PaddingRight = UDim.new(0, 5)
    })
    padding.Parent = button

    button.MouseButton1Click:Connect(callback)
    return button
end

function MultiGrinder:createTextBox(text, size, position, initialText, callback)
    local textBox = createGUIElement("TextBox", {
        Size = UDim2.new(0, size.X, 0, size.Y),
        Position = UDim2.new(0, position.X, 0, position.Y),
        Text = initialText,
        PlaceholderText = text,
        Font = self.Config.Font,
        TextSize = 12,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = Color3.fromRGB(52, 73, 94),
        BorderSizePixel = 0,
    })

    textBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            callback(textBox.Text)
        end
    end)
    return textBox
end

function MultiGrinder:createToggle(text, position, initialValue, callback)
    local frame = createGUIElement("Frame", {
        Size = UDim2.new(0, 150, 0, 25),
        Position = UDim2.new(0, position.X, 0, position.Y),
        BackgroundColor3 = Color3.fromRGB(44, 62, 80),
        BorderSizePixel = 0,
    })
    
    local label = createGUIElement("TextLabel", {
        Size = UDim2.new(0.6, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        Text = text,
        Font = self.Config.Font,
        TextSize = 14,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = Color3.fromRGB(44, 62, 80),
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 2
    })
    label.Parent = frame
    
    local toggleButton = createGUIElement("TextButton", {
        Size = UDim2.new(0.4, 0, 1, 0),
        Position = UDim2.new(0.6, 0, 0, 0),
        Text = initialValue and "ON" or "OFF",
        Font = self.Config.Font,
        TextSize = 14,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = initialValue and Color3.fromRGB(46, 204, 113) or Color3.fromRGB(231, 76, 60),
        BorderSizePixel = 0,
        AutoButtonColor = false,
        ZIndex = 2
    })
    toggleButton.Parent = frame
    
    local currentValue = initialValue
    toggleButton.MouseButton1Click:Connect(function()
        currentValue = not currentValue
        toggleButton.Text = currentValue and "ON" or "OFF"
        toggleButton.BackgroundColor3 = currentValue and Color3.fromRGB(46, 204, 113) or Color3.fromRGB(231, 76, 60)
        callback(currentValue)
    end)
    
    return frame
end


function MultiGrinder:showTab(tabName)
    local Frame = self.ScreenGui:FindFirstChild("MainFrame")
    if not Frame then return end

    local TabContent = Frame:FindFirstChild("TabContent")
    if not TabContent then return end

    for _, child in ipairs(TabContent:GetChildren()) do
        if child:IsA("Frame") and child.Name:match("^%a+$") then
            child.Visible = (child.Name == tabName)
        end
    end
    self.CurrentTab = tabName
end

function MultiGrinder:setMinimizedState(isMinimized)
    local Frame = self.ScreenGui:FindFirstChild("MainFrame")
    if not Frame then return end

    local TabContent = Frame:FindFirstChild("TabContent")
    local InfoLabel = Frame:FindFirstChild("InfoLabel")
    local HeaderFrame = Frame:FindFirstChild("HeaderFrame")

    if TabContent and InfoLabel and HeaderFrame then
        if isMinimized then
            Frame.Size = UDim2.new(0, 300, 0, 60) -- Minimized Size
            TabContent.Visible = false
            InfoLabel.Visible = true
            HeaderFrame.Size = UDim2.new(1, 0, 0, 30)
        else
            Frame.Size = UDim2.new(0, 300, 0, 320) -- Full Size
            TabContent.Visible = true
            InfoLabel.Visible = true
            HeaderFrame.Size = UDim2.new(1, 0, 0, 30)
        end
    end
    self.IsMinimized = isMinimized
end


local function disableCamera(self)
    self.OriginalCameraType = Camera.CameraType
    self.OriginalCameraSubject = Camera.CameraSubject
    Camera.CameraType = Enum.CameraType.Scriptable
end

local function restoreCamera(self)
    if self.OriginalCameraType then
        Camera.CameraType = self.OriginalCameraType
        Camera.CameraSubject = self.OriginalCameraSubject
    end
end

function MultiGrinder:setupGUI()
    local ScreenGui = createGUIElement("ScreenGui", {
        Name = "MultiGrinderGUI",
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        ResetOnSpawn = false
    })
    ScreenGui.Parent = LocalPlayer.PlayerGui
    self.ScreenGui = ScreenGui

    local MainFrame = createGUIElement("Frame", {
        Name = "MainFrame",
        Size = UDim2.new(0, 300, 0, 320),
        Position = UDim2.new(0.5, -150, 0, 20),
        BackgroundColor3 = self.Config.MainColor,
        BorderSizePixel = 0,
        ZIndex = 100
    })
    MainFrame.Parent = ScreenGui

    -- UI CORNER
    createGUIElement("UICorner", { CornerRadius = UDim.new(0, 5) }).Parent = MainFrame

    -- HEADER
    local HeaderFrame = createGUIElement("Frame", {
        Name = "HeaderFrame",
        Size = UDim2.new(1, 0, 0, 30),
        BackgroundColor3 = self.Config.AccentColor,
        BorderSizePixel = 0,
    })
    HeaderFrame.Parent = MainFrame
    
    createGUIElement("TextLabel", {
        Size = UDim2.new(0.5, 0, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        Text = "Multi-Bot V44",
        Font = self.Config.Font,
        TextSize = 18,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = Color3.new(0, 0, 0),
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
    }).Parent = HeaderFrame
    
    local StatusLabel = createGUIElement("TextLabel", {
        Name = "StatusLabel",
        Size = UDim2.new(0.4, 0, 1, 0),
        Position = UDim2.new(0.5, 0, 0, 0),
        Text = "Status: DISABLED",
        Font = self.Config.Font,
        TextSize = 14,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = Color3.new(0, 0, 0),
        BackgroundTransparency = 1,
    })
    StatusLabel.Parent = HeaderFrame
    self:updateGUIState()

    local MinimizeButton = self:createButton("-", Vector2.new(30, 30), Vector2.new(240, 0), function()
        self:setMinimizedState(not self.IsMinimized)
    end)
    MinimizeButton.TextSize = 18
    MinimizeButton.Parent = HeaderFrame

    local CloseButton = self:createButton("X", Vector2.new(30, 30), Vector2.new(270, 0), function()
        if self.LoopThread then task.cancel(self.LoopThread) end
        restoreCamera(self)
        ScreenGui:Destroy()
        print("[Multi-Bot Debug] Bot script shut down.")
    end)
    CloseButton.BackgroundColor3 = Color3.fromRGB(192, 57, 43)
    CloseButton.TextSize = 18
    CloseButton.Parent = HeaderFrame

    -- INFO LABEL (visible even when minimized)
    local InfoLabel = createGUIElement("TextLabel", {
        Name = "InfoLabel",
        Size = UDim2.new(1, 0, 0, 30),
        Position = UDim2.new(0, 0, 0, 30),
        Text = "Mode: Combat | Ready",
        Font = self.Config.Font,
        TextSize = 14,
        TextColor3 = self.Config.TextColor,
        BackgroundColor3 = Color3.fromRGB(52, 73, 94),
        BorderSizePixel = 0,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
    })
    InfoLabel.Parent = MainFrame
    
    -- TAB CONTENT
    local TabContent = createGUIElement("Frame", {
        Name = "TabContent",
        Size = UDim2.new(1, 0, 1, -60),
        Position = UDim2.new(0, 0, 0, 60),
        BackgroundColor3 = self.Config.MainColor,
        BorderSizePixel = 0,
    })
    TabContent.Parent = MainFrame
    
    -- TABS
    local TabFrame = createGUIElement("Frame", {
        Size = UDim2.new(1, 0, 0, 25),
        BackgroundColor3 = Color3.fromRGB(52, 73, 94),
    })
    TabFrame.Parent = TabContent
    
    local combatTabButton = self:createButton("Combat", Vector2.new(75, 25), Vector2.new(0, 0), function() 
        self.Mode = "Combat" 
        self:showTab("Combat") 
        self:updateStatus("Ready")
    end)
    combatTabButton.Parent = TabFrame
    
    local miningTabButton = self:createButton("Mining", Vector2.new(75, 25), Vector2.new(75, 0), function() 
        self.Mode = "Mining" 
        self:showTab("Mining") 
        self:updateStatus("Ready")
    end)
    miningTabButton.Parent = TabFrame
    
    local generalTabButton = self:createButton("General", Vector2.new(75, 25), Vector2.new(150, 0), function() 
        self:showTab("General") 
        self:updateStatus("Configuration")
    end)
    generalTabButton.Parent = TabFrame

    -- COMBAT TAB
    local CombatTab = createGUIElement("Frame", {
        Name = "Combat",
        Size = UDim2.new(1, 0, 1, -25),
        Position = UDim2.new(0, 0, 0, 25),
        BackgroundColor3 = self.Config.MainColor,
        BorderSizePixel = 0,
        Visible = true
    })
    CombatTab.Parent = TabContent
    
    local targetNamesTextBox = self:createTextBox("Target Names (Mob_A, Mob_B)", Vector2.new(280, 25), Vector2.new(10, 5), table.concat(self.Config.TargetNames, ", "), function(text)
        self.Config.TargetNames = parseNameList(text)
    end)
    targetNamesTextBox.Parent = CombatTab

    -- Priority Toggles/Inputs
    local areaPriorityToggle = self:createToggle("Area Priority:", Vector2.new(10, 40), self.Config.AreaPriorityEnabled, function(value)
        self.Config.AreaPriorityEnabled = value
    end)
    areaPriorityToggle.Parent = CombatTab
    
    local priorityNamesTextBox = self:createTextBox("Priority Mob Names (First > Last)", Vector2.new(280, 25), Vector2.new(10, 75), table.concat(self.Config.PriorityMobNames, ", "), function(text)
        self.Config.PriorityMobNames = parseNameList(text)
    end)
    priorityNamesTextBox.Parent = CombatTab

    -- Priority Area Buttons
    -- *** MODIFIED: Changed button text radius from 50 to 25 ***
    local setAreaButton = self:createButton("Set Priority Area (Radius 25)", Vector2.new(150, 25), Vector2.new(10, 110), function()
        local hrp = self:getHumanoidRootPart()
        if hrp then
            if #self.PriorityAreas < 5 then
                local newArea = {
                    Center = hrp.Position, 
                    Id = HttpService:GenerateGUID(false)
                }
                table.insert(self.PriorityAreas, newArea)
                self:updateStatus(string.format("Area Set: %d/%d", #self.PriorityAreas, 5))
            else
                self:updateStatus("Max 5 Areas Reached!")
            end
        end
    end)
    setAreaButton.Parent = CombatTab

    local clearAreaButton = self:createButton("Clear Priority Areas", Vector2.new(120, 25), Vector2.new(170, 110), function()
        self.PriorityAreas = {}
        self:updateStatus("Priority Areas Cleared")
    end)
    clearAreaButton.Parent = CombatTab


    -- MINING TAB
    local MiningTab = createGUIElement("Frame", {
        Name = "Mining",
        Size = UDim2.new(1, 0, 1, -25),
        Position = UDim2.new(0, 0, 0, 25),
        BackgroundColor3 = self.Config.MainColor,
        BorderSizePixel = 0,
        Visible = false
    })
    MiningTab.Parent = TabContent
    
    local miningNamesTextBox = self:createTextBox("Mining Resource Names (A, B)", Vector2.new(280, 25), Vector2.new(10, 5), table.concat(self.Config.MiningNames, ", "), function(text)
        self.Config.MiningNames = parseNameList(text)
    end)
    miningNamesTextBox.Parent = MiningTab
    
    -- GENERAL TAB
    local GeneralTab = createGUIElement("Frame", {
        Name = "General",
        Size = UDim2.new(1, 0, 1, -25),
        Position = UDim2.new(0, 0, 0, 25),
        BackgroundColor3 = self.Config.MainColor,
        BorderSizePixel = 0,
        Visible = false
    })
    GeneralTab.Parent = TabContent

    local autoIgnoreToggle = self:createToggle("10s Auto-Ignore:", Vector2.new(10, 5), self.Config.AutoIgnoreEnabled, function(value)
        self.Config.AutoIgnoreEnabled = value
    end)
    autoIgnoreToggle.Parent = GeneralTab

    local toggleButton = self:createButton("ENABLE (F2)", Vector2.new(280, 25), Vector2.new(10, 160), function()
        self.Enabled = not self.Enabled
        self:updateGUIState()
    end)
    toggleButton.Name = "ToggleButton"
    toggleButton.Parent = MainFrame

    toggleButton.MouseButton1Click:Connect(function()
        self.Enabled = not self.Enabled
        self:updateGUIState()
        self:setMinimizedState(self.IsMinimized)
    end)

    CloseButton.MouseButton1Click:Connect(function()
        if self.LoopThread then task.cancel(self.LoopThread) end
        restoreCamera(self)
        ScreenGui:Destroy()
        print("[Multi-Bot Debug] Bot script shut down.")
    end)
    
    self:setMinimizedState(self.IsMinimized)
    self:showTab(self.CurrentTab)
end

--//========================================================================================
--// MAIN LOOP
--//========================================================================================

function MultiGrinder:start()
    self:setupGUI()
    print("[Multi-Bot Debug] GUI Initialized. Starting main loop.")
    
    self.LoopThread = task.spawn(function()
        while task.wait(CONFIG.FarmSpeed) do
            if self.Enabled then
                local hrp = self:getHumanoidRootPart()
                
                if not hrp then 
                    continue 
                end
                
                if self.Mode == "Combat" then
                    self:executeCombatAction(hrp)
                elseif self.Mode == "Mining" then
                    self:executeMiningAction(hrp)
                end
            end
        end
    end)
end

--//========================================================================================
--// SCRIPT EXECUTION
--//========================================================================================

pcall(function()
    local bot = MultiGrinder:new()
    bot:start()
end)
