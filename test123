--[[
  Refactored Multi-Bot (V60 - CRITICAL UI OVERHAUL)
  
  *** V60 CRITICAL FIXES ***
  1. Layout Overhaul: Removed the unpredictable UIListLayout. The TitleBar, Tabs, and ContentContainer are now absolutely positioned, guaranteeing the 340px height for content and fixing the "blank page" issue.
  2. Manual Dragging: Replaced the flaky 'Draggable = true' property with a custom drag script bound to the TitleBar. This ensures the frame can be moved.
  3. Input Fix: Set ScreenGui.IgnoreGuiInset = true for better button responsiveness near the top of the screen.
--]]

--//========================================================================================
--// ESSENTIAL SERVICES & CONFIGURATION
--//========================================================================================
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse() 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui") 

local MultiGrinder = {}
MultiGrinder.__index = MultiGrinder

local CONFIG = {
    ScriptName = "Studlands",
    DefaultMode = "Combat", 
    FarmSpeed = 0.05,
    
    DefaultCombatToolName = "Katana", 
    DefaultCombatTargetNames = "Warrior,Archer,Mage,Boss", 
    
    DefaultMiningToolName = "Iron Pickaxe",
    DefaultMiningTargetNames = "Iron,Rock",
    
    MaxLogLines = 10,
}

--//========================================================================================
--// INITIALIZATION
--//========================================================================================

function MultiGrinder:new()
    local self = setmetatable({}, MultiGrinder)

    if LocalPlayer then
        self.Player = LocalPlayer
        -- Aggressive parenting: parent to PlayerGui if available
        self.GUIParent = LocalPlayer:FindFirstChild("PlayerGui") or StarterGui
    else
        print("[Multi-Bot Debug] ERROR: LocalPlayer not found during initialization.")
        return nil 
    end
    
    -- State Variables
    self.Enabled = false 
    self.Mode = CONFIG.DefaultMode 
    self.CurrentTarget = nil 
    self.CurrentTargetIdentifier = nil 
    self.TargetAcquiredTime = nil 
    self.OriginalCameraCFrame = nil 
    self.EquippedToolName = nil 
    self.IsMinimized = false 
    self.CurrentTab = "General"
    self.LoopThread = nil
    self.DebugLog = {} 
    
    -- Feature Variables
    self.IgnoredTargets = {} 
    self.AutoIgnoreEnabled = true 
    
    -- Combat Variables
    self.CombatToolName = CONFIG.DefaultCombatToolName
    self.CombatTargetNames = CONFIG.DefaultCombatTargetNames
    self.PriorityLocations = {} 
    self.CurrentPriorityLocation = nil 
    
    -- Mining Variables
    self.MiningToolName = CONFIG.DefaultMiningToolName
    self.MiningTargetNames = CONFIG.DefaultMiningTargetNames
    
    -- Remote Event References (Set to common placeholders)
    self.RemoteNames = {
        Equip = "EquipToolEvent",
        Attack = "AttackRemote",
        Teleport = "TeleportRemote",
    }
    
    -- Actual Remote Event Instances (resolved at runtime)
    self.Remotes = {
        Equip = nil,
        Attack = nil,
        Teleport = nil,
    }

    return self
end

--//========================================================================================
--// DEBUGGING & LOGGING
--//========================================================================================

function MultiGrinder:log(message)
    local timeStr = os.date("%H:%M:%S", os.time())
    local cleanMessage = string.format("[%s] %s", timeStr, message)
    
    table.insert(self.DebugLog, 1, cleanMessage) 
    
    while #self.DebugLog > CONFIG.MaxLogLines do
        table.remove(self.DebugLog)
    end
    
    if self.MainGui and self.MainGui.GeneralPage and self.MainGui.GeneralPage.DebugLogLabel then
        self.MainGui.GeneralPage.DebugLogLabel.Text = table.concat(self.DebugLog, "\n")
    end
    
    print("[Multi-Bot LOG] " .. message)
end

--//========================================================================================
--// HELPER FUNCTIONS (UNCHANGED)
--//========================================================================================
-- (Functions like resolveRemotes, getHumanoidRootPart, equipTool, attack, teleport, saveCamera, 
-- restoreCamera, getTargetNames, findClosestTarget remain identical to V59 logic)

function MultiGrinder:resolveRemotes()
    self:log("Resolving remote events...")
    
    -- Look deep into ReplicatedStorage
    self.Remotes.Equip = ReplicatedStorage:FindFirstChild(self.RemoteNames.Equip, true)
    self.Remotes.Attack = ReplicatedStorage:FindFirstChild(self.RemoteNames.Attack, true)
    self.Remotes.Teleport = ReplicatedStorage:FindFirstChild(self.RemoteNames.Teleport, true)

    if self.MainGui and self.MainGui.RemotesPage then
        self:updateGUI()
    end
    
    if self.Remotes.Attack then
        self:log(string.format("Attack Remote found: %s", self.Remotes.Attack.Name))
    else
        self:log(string.format("Attack Remote MISSING: %s", self.RemoteNames.Attack))
    end
end

function MultiGrinder:getHumanoidRootPart()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

function MultiGrinder:equipTool(toolName)
    if self.EquippedToolName == toolName then return true end
    
    self:log(string.format("Attempting to equip tool: %s", toolName))

    local tool = LocalPlayer.Backpack:FindFirstChild(toolName) or LocalPlayer.Character:FindFirstChild(toolName)
    
    if tool and self.Remotes.Equip then
        self.Remotes.Equip:FireServer(tool)
        self.EquippedToolName = toolName
        self:log(string.format("Equipped tool via Remote: %s", toolName))
        return true
    elseif tool then
        tool.Parent = LocalPlayer.Character
        self.EquippedToolName = toolName
        self:log(string.format("Equipped tool via Parenting (Fallback): %s", toolName))
        return true
    end
    
    self:log(string.format("FAILED to equip tool '%s': Tool or Equip Remote not found.", toolName))
    return false
end

function MultiGrinder:attack(target)
    if self.Remotes.Attack then
        self:log(string.format("Firing Attack Remote on: %s", target.Name))
        self.Remotes.Attack:FireServer(target)
    else
        self:log("Attack Remote is MISSING. Falling back to tool activation.")
    end
    
    local tool = LocalPlayer.Character:FindFirstChild(self.EquippedToolName)
    if tool and tool:IsA("Tool") and tool.Activated then
        tool.Activated:Fire()
    end
end

function MultiGrinder:teleport(position)
    local hrp = self:getHumanoidRootPart()
    if not hrp then return end
    
    local targetCFrame = CFrame.new(position + Vector3.new(0, 3, 0))

    if self.Remotes.Teleport then
        self:log("Firing Teleport Remote.")
        self.Remotes.Teleport:FireServer(targetCFrame)
    else
        hrp.CFrame = targetCFrame
        self:log("Using Direct CFrame Teleport (Fallback).")
    end
end

function MultiGrinder:saveCamera(hrp)
    if not self.OriginalCameraCFrame and hrp then
        self.OriginalCameraCFrame = Camera.CFrame
        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 10, 0), hrp.Position + Vector3.new(0, 5, -10))
    end
end

local function restoreCamera(self)
    if self.OriginalCameraCFrame then 
        Camera.CFrame = self.OriginalCameraCFrame 
        Camera.CameraType = Enum.CameraType.Custom
        self.OriginalCameraCFrame = nil 
    end
end

function MultiGrinder:getTargetNames(mode)
    local targetString = (mode == "Combat") and self.CombatTargetNames or self.MiningTargetNames
    local names = {}
    
    if targetString and targetString ~= "" then
        for name in string.gmatch(targetString, "[^,]+") do
            table.insert(names, string.trim(name))
        end
    end
    
    return names
end

function MultiGrinder:findClosestTarget(position, names)
    local closestTargetPart = nil 
    local closestTargetKey = nil 
    local minDistance = math.huge
    
    for _, obj in ipairs(Workspace:GetChildren()) do
        local targetPart = nil
        local targetKey = nil
        
        if self.Mode == "Combat" and obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and obj ~= LocalPlayer.Character then
            local humanoid = obj:FindFirstChildOfClass("Humanoid")
            local hrp = obj:FindFirstChild("HumanoidRootPart")
            
            if not hrp or not humanoid or humanoid.Health <= 0 then continue end
            
            targetPart = hrp
            targetKey = obj
            
            if self.IgnoredTargets[targetKey] then continue end
            
            local distToPlayer = (targetPart.Position - position).Magnitude

            for _, name in ipairs(names) do
                if string.lower(obj.Name) == string.lower(name) and distToPlayer < minDistance then 
                    minDistance = distToPlayer
                    closestTargetPart = targetPart
                    closestTargetKey = targetKey
                    break 
                end
            end
        
        elseif self.Mode == "Mining" and obj:IsA("BasePart") then
             for _, name in ipairs(names) do
                if string.lower(obj.Name) == string.lower(name) then 
                    targetPart = obj
                    targetKey = obj
                    
                    if self.IgnoredTargets[targetKey] then continue end

                    local dist = (targetPart.Position - position).Magnitude
                    if dist < minDistance then
                        minDistance = dist
                        closestTargetPart = targetPart
                        closestTargetKey = targetKey
                    end
                    break 
                end
            end
        end
    end 
    
    return closestTargetPart, closestTargetKey, nil 
end

function MultiGrinder:executeCombatAction(hrp)
    local toolName = self.CombatToolName
    local target = self.CurrentTarget
    
    local needsNewTarget = not target or not target.Parent 

    if needsNewTarget then
        local targetNames = self:getTargetNames("Combat")
        
        local newTarget, newTargetKey = self:findClosestTarget(hrp.Position, targetNames)
        
        if not newTarget then 
            self:log("Combat Targets NOT found. Waiting...") 
            self.CurrentTarget = nil 
            restoreCamera(self) 
            self:updateGUI() 
            return false 
        end
        
        self.CurrentTarget = newTarget
        self.CurrentTargetIdentifier = newTargetKey 
        self.TargetAcquiredTime = tick() 
        self:log(string.format("Acquired Target: %s", newTargetKey.Name)) 
        self:updateGUI()
        
        self:teleport(newTarget.Position)
        self:saveCamera(hrp)
        
    else
        if not self:equipTool(toolName) then
            return false 
        end
        
        local targetModel = self.CurrentTargetIdentifier 
        local humanoid = targetModel and targetModel:FindFirstChildOfClass("Humanoid")
        
        if self.AutoIgnoreEnabled and humanoid and self.TargetAcquiredTime and (tick() - self.TargetAcquiredTime > 10) then
            
            if humanoid.Health <= 0 then
                 self:log(string.format("Target %s is dead.", targetModel.Name))
            else
                 self:log(string.format("Target %s alive for > 10s. Auto-ignoring.", targetModel.Name))
            end

            if self.CurrentTargetIdentifier then
                self.IgnoredTargets[self.CurrentTargetIdentifier] = true 
            end
            
            self.CurrentTarget = nil 
            restoreCamera(self)
            self:updateGUI()
            return false 
        end
        
        self:teleport(target.Position)
        self:attack(targetModel)
    end
    
    return true
end

function MultiGrinder:executeMiningAction(hrp)
    local toolName = self.MiningToolName
    local resource = self.CurrentTarget

    local needsNewTarget = not resource or not resource.Parent

    if needsNewTarget then
        local targetNames = self:getTargetNames("Mining")
        
        local newResource, newResourceKey = self:findClosestTarget(hrp.Position, targetNames)
        
        if not newResource then 
            self:log("Mining Targets NOT found. Waiting...") 
            self.CurrentTarget = nil 
            restoreCamera(self)
            self:updateGUI()
            return false 
        end
        
        self.CurrentTarget = newResource
        self.CurrentTargetIdentifier = newResourceKey 
        self.TargetAcquiredTime = tick() 
        self:log(string.format("Acquired Resource: %s", newResourceKey.Name)) 
        self:updateGUI()
        
        self:teleport(newResource.Position)
        self:saveCamera(hrp)
        
    else
        if not self:equipTool(toolName) then
            return false 
        end
        
        self:teleport(resource.Position)
        
        self:attack(self.CurrentTargetIdentifier)
    end
    
    return true
end


--//========================================================================================
--// GUI (OVERHAULED FOR ABSOLUTE POSITIONING)
--//========================================================================================

function MultiGrinder:setMinimizedState(isMinimized)
    if not self.MainGui or not self.MainGui.MainFrame then return end
    
    self.IsMinimized = isMinimized
    local MainFrame = self.MainGui.MainFrame
    local Tabs = self.MainGui.Tabs
    local ContentContainer = self.MainGui.ContentContainer

    -- Resize the main frame (400px tall when maximized)
    MainFrame.Size = isMinimized and UDim2.new(0, 300, 0, 30) or UDim2.new(0, 300, 0, 400)
    
    -- Hide/show tabs and content containers
    Tabs.Visible = not isMinimized
    ContentContainer.Visible = not isMinimized
    
    -- Update the minimize button text
    self.MainGui.MinimizeButton.Text = isMinimized and "+" or "−" 
    
    -- Ensure content pages are only visible when maximized AND it's the current tab
    for _, page in pairs(self.MainGui.Pages) do
        local isCurrentTab = (page.Name == self.CurrentTab .. "Page")
        page.Visible = not isMinimized and isCurrentTab
    end
end

function MultiGrinder:getRemoteStatus(remoteName)
    local remote = self.Remotes[remoteName]
    local name = self.RemoteNames[remoteName]
    
    if remote then
        return string.format("Found: %s (Type: %s)", remote.Name, remote.ClassName), Color3.fromRGB(50, 150, 50) -- Green
    else
        return string.format("Missing: %s", name), Color3.fromRGB(150, 50, 50) -- Red
    end
end

function MultiGrinder:updateGUI()
    if self.MainGui then
        -- General Tab
        local ToggleButton = self.MainGui.GeneralPage.ToggleButton
        ToggleButton.Text = self.Enabled and "Auto Farm: ON" or "Auto Farm: OFF"
        ToggleButton.BackgroundColor3 = self.Enabled and Color3.fromRGB(70, 150, 70) or Color3.fromRGB(150, 70, 70)
        self.MainGui.GeneralPage.ModeButton.Text = "Mode: " .. self.Mode
        self.MainGui.GeneralPage.AutoIgnoreButton.Text = self.AutoIgnoreEnabled and "10s Auto-Ignore: ON" or "10s Auto-Ignore: OFF"
        
        -- Combat Tab
        if self.MainGui.CombatPage and self.MainGui.CombatPage.PriorityCountLabel then
            self.MainGui.CombatPage.PriorityCountLabel.Text = string.format("Priority Locations: %d / 10", #self.PriorityLocations)
        end
        
        -- Remotes Tab
        if self.MainGui.RemotesPage then
            local equipStatus, equipColor = self:getRemoteStatus("Equip")
            self.MainGui.RemotesPage.EquipStatusLabel.Text = equipStatus
            self.MainGui.RemotesPage.EquipStatusLabel.TextColor3 = equipColor
            
            local attackStatus, attackColor = self:getRemoteStatus("Attack")
            self.MainGui.RemotesPage.AttackStatusLabel.Text = attackStatus
            self.MainGui.RemotesPage.AttackStatusLabel.TextColor3 = attackColor
            
            local teleportStatus, teleportColor = self:getRemoteStatus("Teleport")
            self.MainGui.RemotesPage.TeleportStatusLabel.Text = teleportStatus
            self.MainGui.RemotesPage.TeleportStatusLabel.TextColor3 = teleportColor
        end
    end
end

-- Custom Drag Function
function MultiGrinder:setupDrag(frameToMove, dragHandle)
    local dragging = false
    local dragStart = nil
    local frameStart = nil

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = UserInputService:GetMouseLocation()
            frameStart = frameToMove.Position
            -- Capture the mouse/touch input
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        end
    end)

    dragHandle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then
                dragging = false
                -- Release the mouse/touch
                UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            end
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local dragDelta = UserInputService:GetMouseLocation() - dragStart
            local newX = frameStart.X.Offset + dragDelta.X
            local newY = frameStart.Y.Offset + dragDelta.Y
            frameToMove.Position = UDim2.new(frameToMove.Position.X.Scale, newX, frameToMove.Position.Y.Scale, newY)
        end
    end)
end

function MultiGrinder:setupGUI()
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "MultiBotGUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.IgnoreGuiInset = true -- CRITICAL FIX 
    ScreenGui.Parent = self.GUIParent

    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 300, 0, 400) -- Max size: 300x400
    MainFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
    MainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = ScreenGui
    -- NOTE: UIListLayout REMOVED to force absolute positioning and fix layout issues.

    
    -- TitleBar (30px high)
    local TitleBar = Instance.new("Frame")
    TitleBar.Size = UDim2.new(1, 0, 0, 30)
    TitleBar.Position = UDim2.new(0, 0, 0, 0) -- Absolute position at top
    TitleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    TitleBar.Parent = MainFrame
    TitleBar.Active = true 
    TitleBar.ZIndex = 2 
    self:setupDrag(MainFrame, TitleBar) -- Use manual drag

    local Title = Instance.new("TextLabel")
    Title.Text = CONFIG.ScriptName
    Title.Size = UDim2.new(1, -60, 1, 0)
    Title.Position = UDim2.new(0, 0, 0, 0)
    Title.BackgroundTransparency = 1
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Font = Enum.Font.GothamBold
    Title.TextSize = 16
    Title.Parent = TitleBar
    Title.ZIndex = 2
    
    local function createButton(parent, text, color, position, size)
        local button = Instance.new("TextButton")
        button.Text = text
        button.Size = size or UDim2.new(0.5, -5, 0, 25)
        button.Position = position or UDim2.new(0, 0, 0, 0)
        button.BackgroundColor3 = color or Color3.fromRGB(70, 70, 70)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.Gotham
        button.TextSize = 14
        button.Parent = parent
        button.ZIndex = 3 -- Ensure buttons are clickable
        return button
    end
    
    -- Minimize/Maximize Button
    local MinimizeButton = createButton(TitleBar, "−", Color3.fromRGB(90, 90, 90), UDim2.new(1, -60, 0, 0), UDim2.new(0, 30, 1, 0))
    MinimizeButton.Name = "MinimizeButton"
    MinimizeButton.ZIndex = 3

    -- Close Button
    local CloseButton = createButton(TitleBar, "X", Color3.fromRGB(150, 40, 40), UDim2.new(1, -30, 0, 0), UDim2.new(0, 30, 1, 0))
    CloseButton.Name = "CloseButton"
    CloseButton.ZIndex = 3

    -- Tabs Container (30px high)
    local Tabs = Instance.new("Frame")
    Tabs.Size = UDim2.new(1, 0, 0, 30)
    Tabs.Position = UDim2.new(0, 0, 0, 30) -- Absolute position below TitleBar (30px)
    Tabs.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    Tabs.Parent = MainFrame
    Tabs.ZIndex = 2 

    local TabLayout = Instance.new("UIListLayout")
    TabLayout.FillDirection = Enum.FillDirection.Horizontal
    TabLayout.Parent = Tabs
    
    local TabNames = {"General", "Combat", "Mining", "Remotes"}
    local TabButtons = {}
    local Pages = {}
    
    function MultiGrinder:showTab(name)
        self.CurrentTab = name
        for tabName, button in pairs(TabButtons) do
            local page = Pages[tabName]
            if tabName == name then
                button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
                if page and not self.IsMinimized then page.Visible = true end
            else
                button.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
                if page then page.Visible = false end
            end
        end
    end
    
    for i, name in ipairs(TabNames) do
        local button = createButton(Tabs, name, Color3.fromRGB(55, 55, 55), nil, UDim2.new(1/#TabNames, 0, 1, 0))
        button.Name = name .. "Tab"
        button.MouseButton1Click:Connect(function()
            self:showTab(name)
        end)
        TabButtons[name] = button
    end
    
    -- Content Container (Fills the remaining space: 400 - 30 - 30 = 340px)
    local ContentContainer = Instance.new("Frame")
    ContentContainer.Size = UDim2.new(1, 0, 0, 340) 
    ContentContainer.Position = UDim2.new(0, 0, 0, 60) -- Absolute position below Tabs (60px)
    ContentContainer.BackgroundTransparency = 1
    ContentContainer.Parent = MainFrame
    ContentContainer.ZIndex = 1
    
    -- Helper functions for creating content
    local function createContentPage(parent, name)
        local page = Instance.new("Frame")
        page.Name = name .. "Page"
        page.Size = UDim2.new(1, 0, 1, 0) -- Fill ContentContainer completely (340px high)
        page.BackgroundTransparency = 1
        page.Visible = false
        page.Parent = parent
        return page
    end
    
    local function createListLayout(parent)
        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 5)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = parent
        return layout
    end
    
    local function createTextBox(parent, defaultText, placeholder)
        local box = Instance.new("TextBox")
        box.Text = defaultText
        box.PlaceholderText = placeholder or ""
        box.Size = UDim2.new(1, -10, 0, 25)
        box.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
        box.TextColor3 = Color3.fromRGB(255, 255, 255)
        box.Font = Enum.Font.Gotham
        box.TextSize = 14
        box.ClearTextOnFocus = false
        box.Parent = parent
        box.ZIndex = 2
        return box
    end
    
    local function createInputLabel(parent, text)
        local label = Instance.new("TextLabel")
        label.Text = text
        label.Size = UDim2.new(1, 0, 0, 20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.Font = Enum.Font.Gotham
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = parent
        label.ZIndex = 2
        return label
    end
    
    local function createStatusLabel(parent, text, color)
        local label = Instance.new("TextLabel")
        label.Text = text
        label.Size = UDim2.new(1, 0, 0, 20)
        label.BackgroundTransparency = 1
        label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
        label.Font = Enum.Font.GothamBold
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = parent
        label.ZIndex = 2
        return label
    end

    -- General Page
    local GeneralPage = createContentPage(ContentContainer, "General")
    local GeneralLayout = createListLayout(GeneralPage)
    GeneralLayout.Padding = UDim.new(0, 5) 
    

    local ToggleButton = createButton(GeneralPage, "Starting...", Color3.fromRGB(70, 70, 70), nil, UDim2.new(1, -10, 0, 30))
    ToggleButton.Name = "ToggleButton"
    ToggleButton.MouseButton1Click:Connect(function()
        self.Enabled = not self.Enabled
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil
        if not self.Enabled then
            restoreCamera(self)
        end
        self:log(string.format("Auto Farm Toggled: %s", self.Enabled and "ON" or "OFF"))
        self:updateGUI()
    end)
    
    local ModeButton = createButton(GeneralPage, "Mode: " .. self.Mode, Color3.fromRGB(70, 70, 150), nil, UDim2.new(1, -10, 0, 30))
    ModeButton.Name = "ModeButton"
    ModeButton.MouseButton1Click:Connect(function()
        self.Mode = (self.Mode == "Combat") and "Mining" or "Combat"
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil 
        restoreCamera(self)
        self:log(string.format("Mode Switched to: %s", self.Mode))
        self:updateGUI()
    end)

    local AutoIgnoreButton = createButton(GeneralPage, "10s Auto-Ignore: ON", Color3.fromRGB(70, 70, 70), nil, UDim2.new(1, -10, 0, 30)) 
    AutoIgnoreButton.Name = "AutoIgnoreButton"
    AutoIgnoreButton.MouseButton1Click:Connect(function()
        self.AutoIgnoreEnabled = not self.AutoIgnoreEnabled
        self:log(string.format("Auto-Ignore Toggled: %s", self.AutoIgnoreEnabled and "ON" or "OFF"))
        self:updateGUI()
    end)

    local IgnoreButton = createButton(GeneralPage, "Ignore Current Target", Color3.fromRGB(100, 100, 100), nil, UDim2.new(1, -10, 0, 30))
    IgnoreButton.Name = "IgnoreButton"
    IgnoreButton.MouseButton1Click:Connect(function()
        if self.CurrentTargetIdentifier then
            self.IgnoredTargets[self.CurrentTargetIdentifier] = true
            self:log(string.format("Manually Ignored Target: %s", self.CurrentTargetIdentifier.Name or "Unknown"))
        end
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        restoreCamera(self)
        self:updateGUI()
    end)
    
    local ClearIgnoreButton = createButton(GeneralPage, "Clear Ignore List", Color3.fromRGB(100, 100, 100), nil, UDim2.new(1, -10, 0, 30))
    ClearIgnoreButton.Name = "ClearIgnoreButton"
    ClearIgnoreButton.MouseButton1Click:Connect(function()
        self.IgnoredTargets = {}
        self:log("Ignore List Cleared.")
        self:updateGUI()
    end)
    
    -- Debug Log Area
    local LogTitle = createInputLabel(GeneralPage, "--- LIVE DEBUG LOG ---")
    LogTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    
    local LogFrame = Instance.new("Frame")
    LogFrame.Size = UDim2.new(1, -10, 0, 130)
    LogFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    LogFrame.Parent = GeneralPage
    LogFrame.ZIndex = 2
    
    local DebugLogLabel = Instance.new("TextLabel")
    DebugLogLabel.Name = "DebugLogLabel"
    DebugLogLabel.Text = "Log Initialized. Starting..."
    DebugLogLabel.Size = UDim2.new(1, -10, 1, -10)
    DebugLogLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    DebugLogLabel.BackgroundTransparency = 1
    DebugLogLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    DebugLogLabel.Font = Enum.Font.Monospace
    DebugLogLabel.TextSize = 10
    DebugLogLabel.TextWrapped = true
    DebugLogLabel.TextXAlignment = Enum.TextXAlignment.Left
    DebugLogLabel.TextYAlignment = Enum.TextYAlignment.Top
    DebugLogLabel.Parent = LogFrame
    DebugLogLabel.ZIndex = 2
    
    local LogPadding = Instance.new("UIPadding")
    LogPadding.PaddingLeft = UDim.new(0, 5)
    LogPadding.PaddingTop = UDim.new(0, 5)
    LogPadding.Parent = LogFrame

    Pages["General"] = GeneralPage

    -- Combat Page
    local CombatPage = createContentPage(ContentContainer, "Combat")
    local CombatLayout = createListLayout(CombatPage)
    CombatLayout.Padding = UDim.new(0, 5) 
    
    createInputLabel(CombatPage, "Combat Tool Name:")
    local CToolNameInput = createTextBox(CombatPage, self.CombatToolName, "E.g., Katana, Sword")
    CToolNameInput.Name = "CToolNameInput"
    CToolNameInput.FocusLost:Connect(function(enterPressed)
        self.CombatToolName = CToolNameInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil
        self:log(string.format("Combat Tool updated: %s", self.CombatToolName))
        self:updateGUI()
    end)
    
    createInputLabel(CombatPage, "Target Mob Names (comma-separated):")
    local CTargetNamesInput = createTextBox(CombatPage, self.CombatTargetNames, "E.g., Warrior, Archer, Boss")
    CTargetNamesInput.Name = "CTargetNamesInput"
    CTargetNamesInput.FocusLost:Connect(function(enterPressed)
        self.CombatTargetNames = CTargetNamesInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self:log(string.format("Combat Targets updated: %s", self.CombatTargetNames))
    end)
    
    -- Priority Locations 
    local PriorityLabel = createInputLabel(CombatPage, "--- Priority Kill Zones (10m Radius) ---")
    PriorityLabel.TextColor3 = Color3.fromRGB(255, 180, 0)
    
    local PriorityCountLabel = createInputLabel(CombatPage, string.format("Priority Locations: %d / 10", #self.PriorityLocations))
    PriorityCountLabel.Name = "PriorityCountLabel"
    
    local AddPriorityButton = createButton(CombatPage, "Add Current Location", Color3.fromRGB(50, 150, 50), nil, UDim2.new(1, -10, 0, 30))
    AddPriorityButton.Name = "AddPriorityButton"
    AddPriorityButton.MouseButton1Click:Connect(function()
        local hrp = self:getHumanoidRootPart()
        if not hrp then self:log("Cannot add location: HRP missing.") return end
        
        if #self.PriorityLocations < 10 then
            local newLoc = hrp.Position
            table.insert(self.PriorityLocations, newLoc)
            self:log(string.format("Added Priority Location: %s", tostring(newLoc)))
            self:updateGUI()
        else
            self:log("Cannot add more than 10 priority locations.")
        end
    end)
    
    local ClearPriorityButton = createButton(CombatPage, "Clear Priority Locations", Color3.fromRGB(150, 50, 50), nil, UDim2.new(1, -10, 0, 30))
    ClearPriorityButton.Name = "ClearPriorityButton"
    ClearPriorityButton.MouseButton1Click:Connect(function()
        self.PriorityLocations = {}
        self.CurrentPriorityLocation = nil 
        self:log("Cleared all priority locations.")
        self:updateGUI()
    end)
    
    Pages["Combat"] = CombatPage

    -- Mining Page
    local MiningPage = createContentPage(ContentContainer, "Mining")
    local MiningLayout = createListLayout(MiningPage)
    MiningLayout.Padding = UDim.new(0, 5) 
    
    createInputLabel(MiningPage, "Mining Tool Name:")
    local MToolNameInput = createTextBox(MiningPage, self.MiningToolName, "E.g., Eternium Pickaxe")
    MToolNameInput.Name = "MToolNameInput"
    MToolNameInput.FocusLost:Connect(function(enterPressed)
        self.MiningToolName = MToolNameInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self.EquippedToolName = nil
        self:log(string.format("Mining Tool updated: %s", self.MiningToolName))
        self:updateGUI()
    end)
    
    createInputLabel(MiningPage, "Resource Names (comma-separated):")
    local MTargetNamesInput = createTextBox(MiningPage, self.MiningTargetNames, "E.g., Iron, Rock, Gold")
    MTargetNamesInput.Name = "MTargetNamesInput"
    MTargetNamesInput.FocusLost:Connect(function(enterPressed)
        self.MiningTargetNames = MTargetNamesInput.Text
        self.CurrentTarget = nil 
        self.CurrentTargetIdentifier = nil 
        self.CurrentPriorityLocation = nil 
        self.TargetAcquiredTime = nil 
        self:log(string.format("Mining Targets updated: %s", self.MiningTargetNames))
    end)
    
    local MRangeLabel = Instance.new("TextLabel")
    MRangeLabel.Text = "Search Range: Full Map (Continuous Mining)"
    MRangeLabel.Size = UDim2.new(1, 0, 0, 20)
    MRangeLabel.BackgroundTransparency = 1
    MRangeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    MRangeLabel.Font = Enum.Font.Gotham
    MRangeLabel.TextSize = 12
    MRangeLabel.TextXAlignment = Enum.TextXAlignment.Center
    MRangeLabel.Parent = MiningPage
    MRangeLabel.ZIndex = 2

    Pages["Mining"] = MiningPage

    -- Remotes Page 
    local RemotesPage = createContentPage(ContentContainer, "Remotes")
    local RemotesLayout = createListLayout(RemotesPage)
    RemotesLayout.Padding = UDim.new(0, 5) 

    local NoteLabel = createInputLabel(RemotesPage, "Input RemoteEvent names found in ReplicatedStorage:")
    NoteLabel.TextColor3 = Color3.fromRGB(255, 180, 0)
    NoteLabel.TextXAlignment = Enum.TextXAlignment.Center
    
    -- EQUIP Remote
    createInputLabel(RemotesPage, "Equip Tool Remote Name:")
    local EquipInput = createTextBox(RemotesPage, self.RemoteNames.Equip, "e.g. 'EquipToolEvent'")
    EquipInput.Name = "EquipInput"
    EquipInput.FocusLost:Connect(function()
        self.RemoteNames.Equip = EquipInput.Text
        self:resolveRemotes()
        self:updateGUI()
    end)
    local EquipStatusLabel = createStatusLabel(RemotesPage, "Status: Not Checked", Color3.fromRGB(255, 255, 255))
    EquipStatusLabel.Name = "EquipStatusLabel"
    
    -- ATTACK Remote
    createInputLabel(RemotesPage, "Attack Remote Name:")
    local AttackInput = createTextBox(RemotesPage, self.RemoteNames.Attack, "e.g. 'AttackRemote' or 'FireClient'")
    AttackInput.Name = "AttackInput"
    AttackInput.FocusLost:Connect(function()
        self.RemoteNames.Attack = AttackInput.Text
        self:resolveRemotes()
        self:updateGUI()
    end)
    local AttackStatusLabel = createStatusLabel(RemotesPage, "Status: Not Checked", Color3.fromRGB(255, 255, 255))
    AttackStatusLabel.Name = "AttackStatusLabel"
    
    -- TELEPORT Remote
    createInputLabel(RemotesPage, "Teleport Remote Name:")
    local TeleportInput = createTextBox(RemotesPage, self.RemoteNames.Teleport, "e.g. 'TeleportEvent'")
    TeleportInput.Name = "TeleportInput"
    TeleportInput.FocusLost:Connect(function()
        self.RemoteNames.Teleport = TeleportInput.Text
        self:resolveRemotes()
        self:updateGUI()
    end)
    local TeleportStatusLabel = createStatusLabel(RemotesPage, "Status: Not Checked", Color3.fromRGB(255, 255, 255))
    TeleportStatusLabel.Name = "TeleportStatusLabel"

    local RecheckButton = createButton(RemotesPage, "Re-Check Remotes", Color3.fromRGB(70, 70, 150), nil, UDim2.new(1, -10, 0, 30))
    RecheckButton.MouseButton1Click:Connect(function()
        self:resolveRemotes()
    end)
    
    Pages["Remotes"] = RemotesPage

    self.MainGui = {
        ScreenGui = ScreenGui,
        MainFrame = MainFrame,
        MinimizeButton = MinimizeButton,
        Tabs = Tabs,
        ContentContainer = ContentContainer, -- Added reference
        Pages = Pages,
        GeneralPage = {
            ToggleButton = ToggleButton,
            ModeButton = ModeButton,
            IgnoreButton = IgnoreButton, 
            ClearIgnoreButton = ClearIgnoreButton, 
            AutoIgnoreButton = AutoIgnoreButton, 
            DebugLogLabel = DebugLogLabel, 
        },
        CombatPage = {
            ToolNameInput = CToolNameInput,
            TargetNamesInput = CTargetNamesInput,
            PriorityCountLabel = PriorityCountLabel,
            AddPriorityButton = AddPriorityButton,
            ClearPriorityButton = ClearPriorityButton,
        },
        MiningPage = {
            ToolNameInput = MToolNameInput,
            TargetNamesInput = MTargetNamesInput,
        },
        RemotesPage = {
            EquipStatusLabel = EquipStatusLabel,
            AttackStatusLabel = AttackStatusLabel,
            TeleportStatusLabel = TeleportStatusLabel,
        }
    }

    MinimizeButton.MouseButton1Click:Connect(function()
        self:setMinimizedState(not self.IsMinimized)
    end)

    CloseButton.MouseButton1Click:Connect(function()
        if self.LoopThread then task.cancel(self.LoopThread) end
        restoreCamera(self)
        ScreenGui:Destroy()
        self:log("Bot script shut down.")
    end)
    
    self:setMinimizedState(self.IsMinimized)
    self:showTab(self.CurrentTab)
    self:log("UI setup complete. Check Remotes tab for missing events.")
end

--//========================================================================================
--// MAIN LOOP
--//========================================================================================

function MultiGrinder:start()
    self.GUIParent = LocalPlayer:FindFirstChild("PlayerGui")
    
    if not self.GUIParent then 
        print("[Multi-Bot Debug] WARNING: PlayerGui not found. Proceeding with StarterGui as parent for setupGUI.")
    end

    pcall(function()
        self:setupGUI()
        self:resolveRemotes() 
        self:updateGUI() 
        self:log("Main loop starting...")
    end)

    
    self.LoopThread = task.spawn(function()
        while task.wait(CONFIG.FarmSpeed) do
            if self.Enabled then
                local hrp = self:getHumanoidRootPart()
                
                if not hrp then 
                    self:log("Waiting for character HRP...")
                    continue 
                end
                
                if self.Mode == "Combat" then
                    self:executeCombatAction(hrp)
                elseif self.Mode == "Mining" then
                    self:executeMiningAction(hrp)
                end
            end
        end
    end)
end

--//========================================================================================
--// SCRIPT EXECUTION
--//========================================================================================

pcall(function()
    local bot = MultiGrinder:new()
    if bot then
        bot:start()
    end
end)
